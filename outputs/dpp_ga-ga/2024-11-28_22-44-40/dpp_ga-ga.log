[2024-11-28 22:44:40,200][root][INFO] - Workspace: E:\all_works\iclr2025\AEL-P-SNE(1)\AEL-P-SNE\outputs\dpp_ga-ga\2024-11-28_22-44-40
[2024-11-28 22:44:40,201][root][INFO] - Project Root: E:\all_works\iclr2025\AEL-P-SNE(1)\AEL-P-SNE
[2024-11-28 22:44:40,201][root][INFO] - Using LLM: deepseek-coder
[2024-11-28 22:44:40,202][root][INFO] - Using Algorithm: reevo2d
[2024-11-28 22:44:41,629][root][INFO] - Problem: dpp_ga
[2024-11-28 22:44:41,630][root][INFO] - Problem description: Assisting in solving black-box decap placement problem with genetic algorithm. The problem requires finding the optimal placement of decaps in a given power grid.
[2024-11-28 22:44:41,631][root][INFO] - Functions name: [run_ga,initialize_population,evolve_population,evaluate_population,crossover,mutate]
[2024-11-28 22:44:41,634][root][INFO] - Evaluating seed function...
[2024-11-28 22:44:41,635][root][INFO] - Seed function code: 
from dataclasses import dataclass
from reward_functions import RewardModel
import random
from typing import List
from typing import Tuple
import numpy as np
def run_ga(n_pop: int, n_iter: int, n_inst: int, elite_rate: float, n_decap: int, reward_model: 'RewardModel') -> float:
    '''
    Runs the Genetic Algorithm (GA) for optimization.

    Args:
        n_pop (int): Population size.
        n_iter (int): Number of generations.
        n_inst (int): Number of test instances.
        elite_rate (float): Percentage of elite individuals.
        n_decap (int): Number of decap.
        reward_model (RewardModel): Reward model for scoring the individuals.
    '''
    sum_reward = 0.0
    for _ in range(n_inst):
        population = initialize_population(n_pop, n_decap, reward_model.n * reward_model.m)
        for _ in range(n_iter):
            population = evolve_population(population, reward_model, elite_rate)
        best_individual = min(population, key=lambda x: x[1])
        sum_reward += best_individual[1]
    return sum_reward / n_inst
def initialize_population(n_pop: int, n_decap: int, total_ports: int) -> List[Tuple[np.ndarray, float]]:
    '''
    Initializes the population with random individuals.

    Args:
        n_pop (int): Population size.
        n_decap (int): Number of decap.
        total_ports (int): Total number of ports.

    Returns:
        List[Tuple[np.ndarray, float]]: List of individuals with their fitness values.
    '''
    population = []
    for _ in range(n_pop):
        pi = np.random.choice(total_ports, n_decap, replace=False)
        probe = random.randint(0, total_ports - 1)
        population.append((pi, probe))
    return population
def evolve_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel', elite_rate: float) -> List[Tuple[np.ndarray, float]]:
    '''
    Evolves the population by selecting, mating, and mutating individuals.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.
        elite_rate (float): Percentage of elite individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: New population after evolution.
    '''
    population = evaluate_population(population, reward_model)
    elite_count = int(elite_rate * len(population))
    population.sort(key=lambda x: x[1])
    elites = population[:elite_count]
    new_population = elites.copy()
    
    while len(new_population) < len(population):
        parent1, parent2 = random.sample(elites, 2)
        child1, child2 = crossover(parent1, parent2)
        child1 = mutate(child1, reward_model.n * reward_model.m)
        child2 = mutate(child2, reward_model.n * reward_model.m)
        new_population.append(child1)
        new_population.append(child2)
    
    return new_population[:len(population)]
def evaluate_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel') -> List[Tuple[np.ndarray, float]]:
    '''
    Evaluates the population by calculating the fitness of each individual.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: Population with fitness values.
    '''
    for i in range(len(population)):
        pi, probe = population[i]
        fitness = reward_model(probe, pi)
        population[i] = (pi, fitness)
    return population
def crossover(parent1: Tuple[np.ndarray, int], parent2: Tuple[np.ndarray, int]) -> Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]:
    '''
    Performs crossover between two parents to produce two children.

    Args:
        parent1 (Tuple[np.ndarray, int]): First parent.
        parent2 (Tuple[np.ndarray, int]): Second parent.

    Returns:
        Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]: Two children.
    '''
    pi1, probe1 = parent1
    pi2, probe2 = parent2
    split_point = random.randint(1, len(pi1) - 1)
    child1_pi = np.concatenate((pi1[:split_point], pi2[split_point:]))
    child2_pi = np.concatenate((pi2[:split_point], pi1[split_point:]))
    child1_probe = probe1 if random.random() < 0.5 else probe2
    child2_probe = probe2 if random.random() < 0.5 else probe1
    return (child1_pi, child1_probe), (child2_pi, child2_probe)
def mutate(individual: Tuple[np.ndarray, int], total_ports: int) -> Tuple[np.ndarray, int]:
    '''
    Mutates an individual by randomly changing some of its genes.

    Args:
        individual (Tuple[np.ndarray, int]): Individual to mutate.
        total_ports (int): Total number of ports.

    Returns:
        Tuple[np.ndarray, int]: Mutated individual.
    '''
    pi, probe = individual
    mutation_rate = 0.1
    for i in range(len(pi)):
        if random.random() < mutation_rate:
            pi[i] = random.randint(0, total_ports - 1)
    if random.random() < mutation_rate:
        probe = random.randint(0, total_ports - 1)
    return (pi, probe)
[2024-11-28 22:44:41,642][root][INFO] - Iteration 0: Running Code 0
[2024-11-28 22:44:42,041][root][INFO] - Iteration 0: Code Run 0 successful!
[2024-11-28 22:46:07,154][root][INFO] - Iteration 0, response_id 0: Objective value: -7.071078256244064
[2024-11-28 22:46:07,155][root][INFO] - Iteration 0: Elitist: -7.071078256244064
[2024-11-28 22:46:07,155][root][INFO] - Iteration 0 finished...
[2024-11-28 22:46:07,155][root][INFO] - Best obj: -7.071078256244064,Best obj func index: 5, Best Code Path: problem_iter0_code0.py
[2024-11-28 22:46:07,156][root][INFO] - Function Evals: 1
[2024-11-28 22:46:07,156][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are an expert-level algorithm engineer. Your task is to design efficient algorithms that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
There is a Markdown document that contains Python code along with relevant explanations. A target function `run_ga` has been selected from this document.
Write a new `run_ga` for problem:
Assisting in solving black-box decap placement problem with genetic algorithm. The problem requires finding the optimal placement of decaps in a given power grid.

Function description:
The function `run_ga` executes a Genetic Algorithm (GA) for optimization, taking the following inputs: `n_pop`, which defines the population size; `n_iter`, representing the number of generations; `n_inst`, the number of test instances to run; `elite_rate`, which specifies the percentage of elite individuals to retain; `n_decap`, indicating the number of decaps (capacitance values in this context); and `reward_model`, a model used to evaluate the fitness of individuals. The function outputs a float representing the average reward over all test instances. During its execution, `run_ga` initializes a population of individuals, evolves them across a set number of iterations by evaluating and selecting the best individuals according to the reward model, and ultimately returns the average fitness of the best individuals found across all instances, serving as a measure of the optimization performance of the genetic algorithm.

markdown document:
```python
import numpy as np
import random
from typing import List, Tuple

def run_ga(n_pop: int, n_iter: int, n_inst: int, elite_rate: float, n_decap: int, reward_model: 'RewardModel') -> float:
    '''
    Runs the Genetic Algorithm (GA) for optimization.

    Args:
        n_pop (int): Population size.
        n_iter (int): Number of generations.
        n_inst (int): Number of test instances.
        elite_rate (float): Percentage of elite individuals.
        n_decap (int): Number of decap.
        reward_model (RewardModel): Reward model for scoring the individuals.
    '''
    sum_reward = 0.0
    for _ in range(n_inst):
        population = initialize_population(n_pop, n_decap, reward_model.n * reward_model.m)
        for _ in range(n_iter):
            population = evolve_population(population, reward_model, elite_rate)
        best_individual = min(population, key=lambda x: x[1])
        sum_reward += best_individual[1]
    return sum_reward / n_inst

def initialize_population(n_pop: int, n_decap: int, total_ports: int) -> List[Tuple[np.ndarray, float]]:
    '''
    Initializes the population with random individuals.

    Args:
        n_pop (int): Population size.
        n_decap (int): Number of decap.
        total_ports (int): Total number of ports.

    Returns:
        List[Tuple[np.ndarray, float]]: List of individuals with their fitness values.
    '''
    population = []
    for _ in range(n_pop):
        pi = np.random.choice(total_ports, n_decap, replace=False)
        probe = random.randint(0, total_ports - 1)
        population.append((pi, probe))
    return population

def evolve_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel', elite_rate: float) -> List[Tuple[np.ndarray, float]]:
    '''
    Evolves the population by selecting, mating, and mutating individuals.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.
        elite_rate (float): Percentage of elite individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: New population after evolution.
    '''
    population = evaluate_population(population, reward_model)
    elite_count = int(elite_rate * len(population))
    population.sort(key=lambda x: x[1])
    elites = population[:elite_count]
    new_population = elites.copy()
    
    while len(new_population) < len(population):
        parent1, parent2 = random.sample(elites, 2)
        child1, child2 = crossover(parent1, parent2)
        child1 = mutate(child1, reward_model.n * reward_model.m)
        child2 = mutate(child2, reward_model.n * reward_model.m)
        new_population.append(child1)
        new_population.append(child2)
    
    return new_population[:len(population)]

def evaluate_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel') -> List[Tuple[np.ndarray, float]]:
    '''
    Evaluates the population by calculating the fitness of each individual.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: Population with fitness values.
    '''
    for i in range(len(population)):
        pi, probe = population[i]
        fitness = reward_model(probe, pi)
        population[i] = (pi, fitness)
    return population

def crossover(parent1: Tuple[np.ndarray, int], parent2: Tuple[np.ndarray, int]) -> Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]:
    '''
    Performs crossover between two parents to produce two children.

    Args:
        parent1 (Tuple[np.ndarray, int]): First parent.
        parent2 (Tuple[np.ndarray, int]): Second parent.

    Returns:
        Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]: Two children.
    '''
    pi1, probe1 = parent1
    pi2, probe2 = parent2
    split_point = random.randint(1, len(pi1) - 1)
    child1_pi = np.concatenate((pi1[:split_point], pi2[split_point:]))
    child2_pi = np.concatenate((pi2[:split_point], pi1[split_point:]))
    child1_probe = probe1 if random.random() < 0.5 else probe2
    child2_probe = probe2 if random.random() < 0.5 else probe1
    return (child1_pi, child1_probe), (child2_pi, child2_probe)

def mutate(individual: Tuple[np.ndarray, int], total_ports: int) -> Tuple[np.ndarray, int]:
    '''
    Mutates an individual by randomly changing some of its genes.

    Args:
        individual (Tuple[np.ndarray, int]): Individual to mutate.
        total_ports (int): Total number of ports.

    Returns:
        Tuple[np.ndarray, int]: Mutated individual.
    '''
    pi, probe = individual
    mutation_rate = 0.1
    for i in range(len(pi)):
        if random.random() < mutation_rate:
            pi[i] = random.randint(0, total_ports - 1)
    if random.random() < mutation_rate:
        probe = random.randint(0, total_ports - 1)
    return (pi, probe)

if __name__ == "__main__":
    n, m = 10, 10
    reward_model = RewardModel(n=n, m=m)
    n_pop = 50
    n_iter = 100
    n_inst = 10
    elite_rate = 0.2
    n_decap = 10
    avg_reward = run_ga(n_pop, n_iter, n_inst, elite_rate, n_decap, reward_model)
    print(f"Average reward over {n_inst} instances: {avg_reward}")
```

### Explanation:
1. **Initialization**: The `initialize_population` function creates a population of random individuals, each with a random set of capacitor placements (`pi`) and a random probing port.
2. **Evaluation**: The `evaluate_population` function calculates the fitness of each individual using the `RewardModel`.
3. **Evolution**: The `evolve_population` function evolves the population by selecting elite individuals, performing crossover, and mutating the individuals.
4. **Crossover**: The `crossover` function combines two parents to produce two children by mixing their capacitor placements.
5. **Mutation**: The `mutate` function introduces random changes to an individual's capacitor placements and probing port.
6. **Main Function**: The `run_ga` function runs the genetic algorithm for a specified number of iterations and instances, returning the average reward.

### Test Code:
The test code initializes the `RewardModel` and runs the genetic algorithm with specified parameters, printing the average reward over multiple instances.```python
import numpy as np
import random
from typing import List, Tuple

def run_ga(n_pop: int, n_iter: int, n_inst: int, elite_rate: float, n_decap: int, reward_model: 'RewardModel') -> float:
    '''
    Runs the Genetic Algorithm (GA) for optimization.

    Args:
        n_pop (int): Population size.
        n_iter (int): Number of generations.
        n_inst (int): Number of test instances.
        elite_rate (float): Percentage of elite individuals.
        n_decap (int): Number of decap.
        reward_model (RewardModel): Reward model for scoring the individuals.
    '''
    sum_reward = 0.0
    for _ in range(n_inst):
        population = initialize_population(n_pop, n_decap, reward_model.n * reward_model.m)
        for _ in range(n_iter):
            population = evolve_population(population, reward_model, elite_rate)
        best_individual = min(population, key=lambda x: x[1])
        sum_reward += best_individual[1]
    return sum_reward / n_inst

def initialize_population(n_pop: int, n_decap: int, total_ports: int) -> List[Tuple[np.ndarray, float]]:
    '''
    Initializes the population with random individuals.

    Args:
        n_pop (int): Population size.
        n_decap (int): Number of decap.
        total_ports (int): Total number of ports.

    Returns:
        List[Tuple[np.ndarray, float]]: List of individuals with their fitness values.
    '''
    population = []
    for _ in range(n_pop):
        pi = np.random.choice(total_ports, n_decap, replace=False)
        probe = random.randint(0, total_ports - 1)
        population.append((pi, probe))
    return population

def evolve_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel', elite_rate: float) -> List[Tuple[np.ndarray, float]]:
    '''
    Evolves the population by selecting, mating, and mutating individuals.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.
        elite_rate (float): Percentage of elite individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: New population after evolution.
    '''
    population = evaluate_population(population, reward_model)
    elite_count = int(elite_rate * len(population))
    population.sort(key=lambda x: x[1])
    elites = population[:elite_count]
    new_population = elites.copy()
    
    while len(new_population) < len(population):
        parent1, parent2 = random.sample(elites, 2)
        child1, child2 = crossover(parent1, parent2)
        child1 = mutate(child1, reward_model.n * reward_model.m)
        child2 = mutate(child2, reward_model.n * reward_model.m)
        new_population.append(child1)
        new_population.append(child2)
    
    return new_population[:len(population)]

def evaluate_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel') -> List[Tuple[np.ndarray, float]]:
    '''
    Evaluates the population by calculating the fitness of each individual.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: Population with fitness values.
    '''
    for i in range(len(population)):
        pi, probe = population[i]
        fitness = reward_model(probe, pi)
        population[i] = (pi, fitness)
    return population

def crossover(parent1: Tuple[np.ndarray, int], parent2: Tuple[np.ndarray, int]) -> Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]:
    '''
    Performs crossover between two parents to produce two children.

    Args:
        parent1 (Tuple[np.ndarray, int]): First parent.
        parent2 (Tuple[np.ndarray, int]): Second parent.

    Returns:
        Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]: Two children.
    '''
    pi1, probe1 = parent1
    pi2, probe2 = parent2
    split_point = random.randint(1, len(pi1) - 1)
    child1_pi = np.concatenate((pi1[:split_point], pi2[split_point:]))
    child2_pi = np.concatenate((pi2[:split_point], pi1[split_point:]))
    child1_probe = probe1 if random.random() < 0.5 else probe2
    child2_probe = probe2 if random.random() < 0.5 else probe1
    return (child1_pi, child1_probe), (child2_pi, child2_probe)

def mutate(individual: Tuple[np.ndarray, int], total_ports: int) -> Tuple[np.ndarray, int]:
    '''
    Mutates an individual by randomly changing some of its genes.

    Args:
        individual (Tuple[np.ndarray, int]): Individual to mutate.
        total_ports (int): Total number of ports.

    Returns:
        Tuple[np.ndarray, int]: Mutated individual.
    '''
    pi, probe = individual
    mutation_rate = 0.1
    for i in range(len(pi)):
        if random.random() < mutation_rate:
            pi[i] = random.randint(0, total_ports - 1)
    if random.random() < mutation_rate:
        probe = random.randint(0, total_ports - 1)
    return (pi, probe)

if __name__ == "__main__":
    n, m = 10, 10
    reward_model = RewardModel(n=n, m=m)
    n_pop = 50
    n_iter = 100
    n_inst = 10
    elite_rate = 0.2
    n_decap = 10
    avg_reward = run_ga(n_pop, n_iter, n_inst, elite_rate, n_decap, reward_model)
    print(f"Average reward over {n_inst} instances: {avg_reward}")
```

### Explanation:
1. **Initialization**: The `initialize_population` function creates a population of random individuals, each with a random set of capacitor placements (`pi`) and a random probing port.
2. **Evaluation**: The `evaluate_population` function calculates the fitness of each individual using the `RewardModel`.
3. **Evolution**: The `evolve_population` function evolves the population by selecting elite individuals, performing crossover, and mutating the individuals.
4. **Crossover**: The `crossover` function combines two parents to produce two children by mixing their capacitor placements.
5. **Mutation**: The `mutate` function introduces random changes to an individual's capacitor placements and probing port.
6. **Main Function**: The `run_ga` function runs the genetic algorithm for a specified number of iterations and instances, returning the average reward.

### Test Code:
The test code initializes the `RewardModel` and runs the genetic algorithm with specified parameters, printing the average reward over multiple instances.

```python
def run_ga(n_pop: int, n_iter: int, n_inst: int, elite_rate: float, n_decap: int, reward_model: 'RewardModel') -> float:
    '''
    Runs the Genetic Algorithm (GA) for optimization.

    Args:
        n_pop (int): Population size.
        n_iter (int): Number of generations.
        n_inst (int): Number of test instances.
        elite_rate (float): Percentage of elite individuals.
        n_decap (int): Number of decap.
        reward_model (RewardModel): Reward model for scoring the individuals.
    '''
    sum_reward = 0.0
    for _ in range(n_inst):
        population = initialize_population(n_pop, n_decap, reward_model.n * reward_model.m)
        for _ in range(n_iter):
            population = evolve_population(population, reward_model, elite_rate)
        best_individual = min(population, key=lambda x: x[1])
        sum_reward += best_individual[1]
    return sum_reward / n_inst

```

Refer to the format of a trivial design above. Be very creative and give `run_ga_v2`. Output code only and enclose your code with Python code block: ```python ... ```.


[2024-11-28 22:46:07,538][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-28 22:46:07,550][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-28 22:46:07,695][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-28 22:46:57,850][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are an expert-level algorithm engineer. Your task is to design efficient algorithms that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
There is a Markdown document that contains Python code along with relevant explanations. A target function `initialize_population` has been selected from this document.
Write a new `initialize_population` for problem:
Assisting in solving black-box decap placement problem with genetic algorithm. The problem requires finding the optimal placement of decaps in a given power grid.

Function description:
The `initialize_population` function is designed to generate an initial population for a genetic algorithm by creating a specified number of random individuals. It takes three inputs: `n_pop`, an integer representing the total population size; `n_decap`, an integer indicating the number of decaps (or capacitors) to be randomly assigned to each individual; and `total_ports`, an integer that defines the total number of available ports. The function outputs a list of tuples, where each tuple consists of a NumPy array (representing the random selection of decap placements) and a float (representing a randomly chosen probing port). This function serves the purpose of initiating the diversity necessary for the evolutionary process in the genetic algorithm, enabling exploration of various configurations in the optimization task.

markdown document:
```python
import numpy as np
import random
from typing import List, Tuple

def run_ga(n_pop: int, n_iter: int, n_inst: int, elite_rate: float, n_decap: int, reward_model: 'RewardModel') -> float:
    '''
    Runs the Genetic Algorithm (GA) for optimization.

    Args:
        n_pop (int): Population size.
        n_iter (int): Number of generations.
        n_inst (int): Number of test instances.
        elite_rate (float): Percentage of elite individuals.
        n_decap (int): Number of decap.
        reward_model (RewardModel): Reward model for scoring the individuals.
    '''
    sum_reward = 0.0
    for _ in range(n_inst):
        population = initialize_population(n_pop, n_decap, reward_model.n * reward_model.m)
        for _ in range(n_iter):
            population = evolve_population(population, reward_model, elite_rate)
        best_individual = min(population, key=lambda x: x[1])
        sum_reward += best_individual[1]
    return sum_reward / n_inst

def initialize_population(n_pop: int, n_decap: int, total_ports: int) -> List[Tuple[np.ndarray, float]]:
    '''
    Initializes the population with random individuals.

    Args:
        n_pop (int): Population size.
        n_decap (int): Number of decap.
        total_ports (int): Total number of ports.

    Returns:
        List[Tuple[np.ndarray, float]]: List of individuals with their fitness values.
    '''
    population = []
    for _ in range(n_pop):
        pi = np.random.choice(total_ports, n_decap, replace=False)
        probe = random.randint(0, total_ports - 1)
        population.append((pi, probe))
    return population

def evolve_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel', elite_rate: float) -> List[Tuple[np.ndarray, float]]:
    '''
    Evolves the population by selecting, mating, and mutating individuals.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.
        elite_rate (float): Percentage of elite individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: New population after evolution.
    '''
    population = evaluate_population(population, reward_model)
    elite_count = int(elite_rate * len(population))
    population.sort(key=lambda x: x[1])
    elites = population[:elite_count]
    new_population = elites.copy()
    
    while len(new_population) < len(population):
        parent1, parent2 = random.sample(elites, 2)
        child1, child2 = crossover(parent1, parent2)
        child1 = mutate(child1, reward_model.n * reward_model.m)
        child2 = mutate(child2, reward_model.n * reward_model.m)
        new_population.append(child1)
        new_population.append(child2)
    
    return new_population[:len(population)]

def evaluate_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel') -> List[Tuple[np.ndarray, float]]:
    '''
    Evaluates the population by calculating the fitness of each individual.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: Population with fitness values.
    '''
    for i in range(len(population)):
        pi, probe = population[i]
        fitness = reward_model(probe, pi)
        population[i] = (pi, fitness)
    return population

def crossover(parent1: Tuple[np.ndarray, int], parent2: Tuple[np.ndarray, int]) -> Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]:
    '''
    Performs crossover between two parents to produce two children.

    Args:
        parent1 (Tuple[np.ndarray, int]): First parent.
        parent2 (Tuple[np.ndarray, int]): Second parent.

    Returns:
        Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]: Two children.
    '''
    pi1, probe1 = parent1
    pi2, probe2 = parent2
    split_point = random.randint(1, len(pi1) - 1)
    child1_pi = np.concatenate((pi1[:split_point], pi2[split_point:]))
    child2_pi = np.concatenate((pi2[:split_point], pi1[split_point:]))
    child1_probe = probe1 if random.random() < 0.5 else probe2
    child2_probe = probe2 if random.random() < 0.5 else probe1
    return (child1_pi, child1_probe), (child2_pi, child2_probe)

def mutate(individual: Tuple[np.ndarray, int], total_ports: int) -> Tuple[np.ndarray, int]:
    '''
    Mutates an individual by randomly changing some of its genes.

    Args:
        individual (Tuple[np.ndarray, int]): Individual to mutate.
        total_ports (int): Total number of ports.

    Returns:
        Tuple[np.ndarray, int]: Mutated individual.
    '''
    pi, probe = individual
    mutation_rate = 0.1
    for i in range(len(pi)):
        if random.random() < mutation_rate:
            pi[i] = random.randint(0, total_ports - 1)
    if random.random() < mutation_rate:
        probe = random.randint(0, total_ports - 1)
    return (pi, probe)

if __name__ == "__main__":
    n, m = 10, 10
    reward_model = RewardModel(n=n, m=m)
    n_pop = 50
    n_iter = 100
    n_inst = 10
    elite_rate = 0.2
    n_decap = 10
    avg_reward = run_ga(n_pop, n_iter, n_inst, elite_rate, n_decap, reward_model)
    print(f"Average reward over {n_inst} instances: {avg_reward}")
```

### Explanation:
1. **Initialization**: The `initialize_population` function creates a population of random individuals, each with a random set of capacitor placements (`pi`) and a random probing port.
2. **Evaluation**: The `evaluate_population` function calculates the fitness of each individual using the `RewardModel`.
3. **Evolution**: The `evolve_population` function evolves the population by selecting elite individuals, performing crossover, and mutating the individuals.
4. **Crossover**: The `crossover` function combines two parents to produce two children by mixing their capacitor placements.
5. **Mutation**: The `mutate` function introduces random changes to an individual's capacitor placements and probing port.
6. **Main Function**: The `run_ga` function runs the genetic algorithm for a specified number of iterations and instances, returning the average reward.

### Test Code:
The test code initializes the `RewardModel` and runs the genetic algorithm with specified parameters, printing the average reward over multiple instances.```python
import numpy as np
import random
from typing import List, Tuple

def run_ga(n_pop: int, n_iter: int, n_inst: int, elite_rate: float, n_decap: int, reward_model: 'RewardModel') -> float:
    '''
    Runs the Genetic Algorithm (GA) for optimization.

    Args:
        n_pop (int): Population size.
        n_iter (int): Number of generations.
        n_inst (int): Number of test instances.
        elite_rate (float): Percentage of elite individuals.
        n_decap (int): Number of decap.
        reward_model (RewardModel): Reward model for scoring the individuals.
    '''
    sum_reward = 0.0
    for _ in range(n_inst):
        population = initialize_population(n_pop, n_decap, reward_model.n * reward_model.m)
        for _ in range(n_iter):
            population = evolve_population(population, reward_model, elite_rate)
        best_individual = min(population, key=lambda x: x[1])
        sum_reward += best_individual[1]
    return sum_reward / n_inst

def initialize_population(n_pop: int, n_decap: int, total_ports: int) -> List[Tuple[np.ndarray, float]]:
    '''
    Initializes the population with random individuals.

    Args:
        n_pop (int): Population size.
        n_decap (int): Number of decap.
        total_ports (int): Total number of ports.

    Returns:
        List[Tuple[np.ndarray, float]]: List of individuals with their fitness values.
    '''
    population = []
    for _ in range(n_pop):
        pi = np.random.choice(total_ports, n_decap, replace=False)
        probe = random.randint(0, total_ports - 1)
        population.append((pi, probe))
    return population

def evolve_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel', elite_rate: float) -> List[Tuple[np.ndarray, float]]:
    '''
    Evolves the population by selecting, mating, and mutating individuals.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.
        elite_rate (float): Percentage of elite individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: New population after evolution.
    '''
    population = evaluate_population(population, reward_model)
    elite_count = int(elite_rate * len(population))
    population.sort(key=lambda x: x[1])
    elites = population[:elite_count]
    new_population = elites.copy()
    
    while len(new_population) < len(population):
        parent1, parent2 = random.sample(elites, 2)
        child1, child2 = crossover(parent1, parent2)
        child1 = mutate(child1, reward_model.n * reward_model.m)
        child2 = mutate(child2, reward_model.n * reward_model.m)
        new_population.append(child1)
        new_population.append(child2)
    
    return new_population[:len(population)]

def evaluate_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel') -> List[Tuple[np.ndarray, float]]:
    '''
    Evaluates the population by calculating the fitness of each individual.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: Population with fitness values.
    '''
    for i in range(len(population)):
        pi, probe = population[i]
        fitness = reward_model(probe, pi)
        population[i] = (pi, fitness)
    return population

def crossover(parent1: Tuple[np.ndarray, int], parent2: Tuple[np.ndarray, int]) -> Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]:
    '''
    Performs crossover between two parents to produce two children.

    Args:
        parent1 (Tuple[np.ndarray, int]): First parent.
        parent2 (Tuple[np.ndarray, int]): Second parent.

    Returns:
        Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]: Two children.
    '''
    pi1, probe1 = parent1
    pi2, probe2 = parent2
    split_point = random.randint(1, len(pi1) - 1)
    child1_pi = np.concatenate((pi1[:split_point], pi2[split_point:]))
    child2_pi = np.concatenate((pi2[:split_point], pi1[split_point:]))
    child1_probe = probe1 if random.random() < 0.5 else probe2
    child2_probe = probe2 if random.random() < 0.5 else probe1
    return (child1_pi, child1_probe), (child2_pi, child2_probe)

def mutate(individual: Tuple[np.ndarray, int], total_ports: int) -> Tuple[np.ndarray, int]:
    '''
    Mutates an individual by randomly changing some of its genes.

    Args:
        individual (Tuple[np.ndarray, int]): Individual to mutate.
        total_ports (int): Total number of ports.

    Returns:
        Tuple[np.ndarray, int]: Mutated individual.
    '''
    pi, probe = individual
    mutation_rate = 0.1
    for i in range(len(pi)):
        if random.random() < mutation_rate:
            pi[i] = random.randint(0, total_ports - 1)
    if random.random() < mutation_rate:
        probe = random.randint(0, total_ports - 1)
    return (pi, probe)

if __name__ == "__main__":
    n, m = 10, 10
    reward_model = RewardModel(n=n, m=m)
    n_pop = 50
    n_iter = 100
    n_inst = 10
    elite_rate = 0.2
    n_decap = 10
    avg_reward = run_ga(n_pop, n_iter, n_inst, elite_rate, n_decap, reward_model)
    print(f"Average reward over {n_inst} instances: {avg_reward}")
```

### Explanation:
1. **Initialization**: The `initialize_population` function creates a population of random individuals, each with a random set of capacitor placements (`pi`) and a random probing port.
2. **Evaluation**: The `evaluate_population` function calculates the fitness of each individual using the `RewardModel`.
3. **Evolution**: The `evolve_population` function evolves the population by selecting elite individuals, performing crossover, and mutating the individuals.
4. **Crossover**: The `crossover` function combines two parents to produce two children by mixing their capacitor placements.
5. **Mutation**: The `mutate` function introduces random changes to an individual's capacitor placements and probing port.
6. **Main Function**: The `run_ga` function runs the genetic algorithm for a specified number of iterations and instances, returning the average reward.

### Test Code:
The test code initializes the `RewardModel` and runs the genetic algorithm with specified parameters, printing the average reward over multiple instances.

```python
def initialize_population(n_pop: int, n_decap: int, total_ports: int) -> List[Tuple[np.ndarray, float]]:
    '''
    Initializes the population with random individuals.

    Args:
        n_pop (int): Population size.
        n_decap (int): Number of decap.
        total_ports (int): Total number of ports.

    Returns:
        List[Tuple[np.ndarray, float]]: List of individuals with their fitness values.
    '''
    population = []
    for _ in range(n_pop):
        pi = np.random.choice(total_ports, n_decap, replace=False)
        probe = random.randint(0, total_ports - 1)
        population.append((pi, probe))
    return population

```

Refer to the format of a trivial design above. Be very creative and give `initialize_population_v2`. Output code only and enclose your code with Python code block: ```python ... ```.


[2024-11-28 22:46:58,057][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-28 22:46:58,189][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-28 22:46:58,450][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-28 22:47:16,636][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are an expert-level algorithm engineer. Your task is to design efficient algorithms that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
There is a Markdown document that contains Python code along with relevant explanations. A target function `evolve_population` has been selected from this document.
Write a new `evolve_population` for problem:
Assisting in solving black-box decap placement problem with genetic algorithm. The problem requires finding the optimal placement of decaps in a given power grid.

Function description:
The `evolve_population` function is designed to evolve a given population of individuals representing potential solutions in a genetic algorithm framework. It takes three inputs: `population`, which is a list of tuples containing individuals (each represented by an array of parameters and a fitness score); `reward_model`, an object used to evaluate the fitness of individuals; and `elite_rate`, a float determining the proportion of the best individuals (elites) to retain for reproduction. The function outputs a new list of tuples representing the evolved population, achieved by first evaluating the current fitness of individuals, selecting a subset of elite individuals based on their fitness scores, and then generating new individuals through crossover and mutation of these elite members. This process aims to improve the population over successive generations by favoring individuals with better performance as assessed by the reward model.

markdown document:
```python
import numpy as np
import random
from typing import List, Tuple

def run_ga(n_pop: int, n_iter: int, n_inst: int, elite_rate: float, n_decap: int, reward_model: 'RewardModel') -> float:
    '''
    Runs the Genetic Algorithm (GA) for optimization.

    Args:
        n_pop (int): Population size.
        n_iter (int): Number of generations.
        n_inst (int): Number of test instances.
        elite_rate (float): Percentage of elite individuals.
        n_decap (int): Number of decap.
        reward_model (RewardModel): Reward model for scoring the individuals.
    '''
    sum_reward = 0.0
    for _ in range(n_inst):
        population = initialize_population(n_pop, n_decap, reward_model.n * reward_model.m)
        for _ in range(n_iter):
            population = evolve_population(population, reward_model, elite_rate)
        best_individual = min(population, key=lambda x: x[1])
        sum_reward += best_individual[1]
    return sum_reward / n_inst

def initialize_population(n_pop: int, n_decap: int, total_ports: int) -> List[Tuple[np.ndarray, float]]:
    '''
    Initializes the population with random individuals.

    Args:
        n_pop (int): Population size.
        n_decap (int): Number of decap.
        total_ports (int): Total number of ports.

    Returns:
        List[Tuple[np.ndarray, float]]: List of individuals with their fitness values.
    '''
    population = []
    for _ in range(n_pop):
        pi = np.random.choice(total_ports, n_decap, replace=False)
        probe = random.randint(0, total_ports - 1)
        population.append((pi, probe))
    return population

def evolve_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel', elite_rate: float) -> List[Tuple[np.ndarray, float]]:
    '''
    Evolves the population by selecting, mating, and mutating individuals.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.
        elite_rate (float): Percentage of elite individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: New population after evolution.
    '''
    population = evaluate_population(population, reward_model)
    elite_count = int(elite_rate * len(population))
    population.sort(key=lambda x: x[1])
    elites = population[:elite_count]
    new_population = elites.copy()
    
    while len(new_population) < len(population):
        parent1, parent2 = random.sample(elites, 2)
        child1, child2 = crossover(parent1, parent2)
        child1 = mutate(child1, reward_model.n * reward_model.m)
        child2 = mutate(child2, reward_model.n * reward_model.m)
        new_population.append(child1)
        new_population.append(child2)
    
    return new_population[:len(population)]

def evaluate_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel') -> List[Tuple[np.ndarray, float]]:
    '''
    Evaluates the population by calculating the fitness of each individual.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: Population with fitness values.
    '''
    for i in range(len(population)):
        pi, probe = population[i]
        fitness = reward_model(probe, pi)
        population[i] = (pi, fitness)
    return population

def crossover(parent1: Tuple[np.ndarray, int], parent2: Tuple[np.ndarray, int]) -> Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]:
    '''
    Performs crossover between two parents to produce two children.

    Args:
        parent1 (Tuple[np.ndarray, int]): First parent.
        parent2 (Tuple[np.ndarray, int]): Second parent.

    Returns:
        Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]: Two children.
    '''
    pi1, probe1 = parent1
    pi2, probe2 = parent2
    split_point = random.randint(1, len(pi1) - 1)
    child1_pi = np.concatenate((pi1[:split_point], pi2[split_point:]))
    child2_pi = np.concatenate((pi2[:split_point], pi1[split_point:]))
    child1_probe = probe1 if random.random() < 0.5 else probe2
    child2_probe = probe2 if random.random() < 0.5 else probe1
    return (child1_pi, child1_probe), (child2_pi, child2_probe)

def mutate(individual: Tuple[np.ndarray, int], total_ports: int) -> Tuple[np.ndarray, int]:
    '''
    Mutates an individual by randomly changing some of its genes.

    Args:
        individual (Tuple[np.ndarray, int]): Individual to mutate.
        total_ports (int): Total number of ports.

    Returns:
        Tuple[np.ndarray, int]: Mutated individual.
    '''
    pi, probe = individual
    mutation_rate = 0.1
    for i in range(len(pi)):
        if random.random() < mutation_rate:
            pi[i] = random.randint(0, total_ports - 1)
    if random.random() < mutation_rate:
        probe = random.randint(0, total_ports - 1)
    return (pi, probe)

if __name__ == "__main__":
    n, m = 10, 10
    reward_model = RewardModel(n=n, m=m)
    n_pop = 50
    n_iter = 100
    n_inst = 10
    elite_rate = 0.2
    n_decap = 10
    avg_reward = run_ga(n_pop, n_iter, n_inst, elite_rate, n_decap, reward_model)
    print(f"Average reward over {n_inst} instances: {avg_reward}")
```

### Explanation:
1. **Initialization**: The `initialize_population` function creates a population of random individuals, each with a random set of capacitor placements (`pi`) and a random probing port.
2. **Evaluation**: The `evaluate_population` function calculates the fitness of each individual using the `RewardModel`.
3. **Evolution**: The `evolve_population` function evolves the population by selecting elite individuals, performing crossover, and mutating the individuals.
4. **Crossover**: The `crossover` function combines two parents to produce two children by mixing their capacitor placements.
5. **Mutation**: The `mutate` function introduces random changes to an individual's capacitor placements and probing port.
6. **Main Function**: The `run_ga` function runs the genetic algorithm for a specified number of iterations and instances, returning the average reward.

### Test Code:
The test code initializes the `RewardModel` and runs the genetic algorithm with specified parameters, printing the average reward over multiple instances.```python
import numpy as np
import random
from typing import List, Tuple

def run_ga(n_pop: int, n_iter: int, n_inst: int, elite_rate: float, n_decap: int, reward_model: 'RewardModel') -> float:
    '''
    Runs the Genetic Algorithm (GA) for optimization.

    Args:
        n_pop (int): Population size.
        n_iter (int): Number of generations.
        n_inst (int): Number of test instances.
        elite_rate (float): Percentage of elite individuals.
        n_decap (int): Number of decap.
        reward_model (RewardModel): Reward model for scoring the individuals.
    '''
    sum_reward = 0.0
    for _ in range(n_inst):
        population = initialize_population(n_pop, n_decap, reward_model.n * reward_model.m)
        for _ in range(n_iter):
            population = evolve_population(population, reward_model, elite_rate)
        best_individual = min(population, key=lambda x: x[1])
        sum_reward += best_individual[1]
    return sum_reward / n_inst

def initialize_population(n_pop: int, n_decap: int, total_ports: int) -> List[Tuple[np.ndarray, float]]:
    '''
    Initializes the population with random individuals.

    Args:
        n_pop (int): Population size.
        n_decap (int): Number of decap.
        total_ports (int): Total number of ports.

    Returns:
        List[Tuple[np.ndarray, float]]: List of individuals with their fitness values.
    '''
    population = []
    for _ in range(n_pop):
        pi = np.random.choice(total_ports, n_decap, replace=False)
        probe = random.randint(0, total_ports - 1)
        population.append((pi, probe))
    return population

def evolve_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel', elite_rate: float) -> List[Tuple[np.ndarray, float]]:
    '''
    Evolves the population by selecting, mating, and mutating individuals.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.
        elite_rate (float): Percentage of elite individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: New population after evolution.
    '''
    population = evaluate_population(population, reward_model)
    elite_count = int(elite_rate * len(population))
    population.sort(key=lambda x: x[1])
    elites = population[:elite_count]
    new_population = elites.copy()
    
    while len(new_population) < len(population):
        parent1, parent2 = random.sample(elites, 2)
        child1, child2 = crossover(parent1, parent2)
        child1 = mutate(child1, reward_model.n * reward_model.m)
        child2 = mutate(child2, reward_model.n * reward_model.m)
        new_population.append(child1)
        new_population.append(child2)
    
    return new_population[:len(population)]

def evaluate_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel') -> List[Tuple[np.ndarray, float]]:
    '''
    Evaluates the population by calculating the fitness of each individual.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: Population with fitness values.
    '''
    for i in range(len(population)):
        pi, probe = population[i]
        fitness = reward_model(probe, pi)
        population[i] = (pi, fitness)
    return population

def crossover(parent1: Tuple[np.ndarray, int], parent2: Tuple[np.ndarray, int]) -> Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]:
    '''
    Performs crossover between two parents to produce two children.

    Args:
        parent1 (Tuple[np.ndarray, int]): First parent.
        parent2 (Tuple[np.ndarray, int]): Second parent.

    Returns:
        Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]: Two children.
    '''
    pi1, probe1 = parent1
    pi2, probe2 = parent2
    split_point = random.randint(1, len(pi1) - 1)
    child1_pi = np.concatenate((pi1[:split_point], pi2[split_point:]))
    child2_pi = np.concatenate((pi2[:split_point], pi1[split_point:]))
    child1_probe = probe1 if random.random() < 0.5 else probe2
    child2_probe = probe2 if random.random() < 0.5 else probe1
    return (child1_pi, child1_probe), (child2_pi, child2_probe)

def mutate(individual: Tuple[np.ndarray, int], total_ports: int) -> Tuple[np.ndarray, int]:
    '''
    Mutates an individual by randomly changing some of its genes.

    Args:
        individual (Tuple[np.ndarray, int]): Individual to mutate.
        total_ports (int): Total number of ports.

    Returns:
        Tuple[np.ndarray, int]: Mutated individual.
    '''
    pi, probe = individual
    mutation_rate = 0.1
    for i in range(len(pi)):
        if random.random() < mutation_rate:
            pi[i] = random.randint(0, total_ports - 1)
    if random.random() < mutation_rate:
        probe = random.randint(0, total_ports - 1)
    return (pi, probe)

if __name__ == "__main__":
    n, m = 10, 10
    reward_model = RewardModel(n=n, m=m)
    n_pop = 50
    n_iter = 100
    n_inst = 10
    elite_rate = 0.2
    n_decap = 10
    avg_reward = run_ga(n_pop, n_iter, n_inst, elite_rate, n_decap, reward_model)
    print(f"Average reward over {n_inst} instances: {avg_reward}")
```

### Explanation:
1. **Initialization**: The `initialize_population` function creates a population of random individuals, each with a random set of capacitor placements (`pi`) and a random probing port.
2. **Evaluation**: The `evaluate_population` function calculates the fitness of each individual using the `RewardModel`.
3. **Evolution**: The `evolve_population` function evolves the population by selecting elite individuals, performing crossover, and mutating the individuals.
4. **Crossover**: The `crossover` function combines two parents to produce two children by mixing their capacitor placements.
5. **Mutation**: The `mutate` function introduces random changes to an individual's capacitor placements and probing port.
6. **Main Function**: The `run_ga` function runs the genetic algorithm for a specified number of iterations and instances, returning the average reward.

### Test Code:
The test code initializes the `RewardModel` and runs the genetic algorithm with specified parameters, printing the average reward over multiple instances.

```python
def evolve_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel', elite_rate: float) -> List[Tuple[np.ndarray, float]]:
    '''
    Evolves the population by selecting, mating, and mutating individuals.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.
        elite_rate (float): Percentage of elite individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: New population after evolution.
    '''
    population = evaluate_population(population, reward_model)
    elite_count = int(elite_rate * len(population))
    population.sort(key=lambda x: x[1])
    elites = population[:elite_count]
    new_population = elites.copy()
    
    while len(new_population) < len(population):
        parent1, parent2 = random.sample(elites, 2)
        child1, child2 = crossover(parent1, parent2)
        child1 = mutate(child1, reward_model.n * reward_model.m)
        child2 = mutate(child2, reward_model.n * reward_model.m)
        new_population.append(child1)
        new_population.append(child2)
    
    return new_population[:len(population)]

```

Refer to the format of a trivial design above. Be very creative and give `evolve_population_v2`. Output code only and enclose your code with Python code block: ```python ... ```.


[2024-11-28 22:47:17,525][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-28 22:47:17,622][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-28 22:47:17,794][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-28 22:48:10,528][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are an expert-level algorithm engineer. Your task is to design efficient algorithms that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
There is a Markdown document that contains Python code along with relevant explanations. A target function `evaluate_population` has been selected from this document.
Write a new `evaluate_population` for problem:
Assisting in solving black-box decap placement problem with genetic algorithm. The problem requires finding the optimal placement of decaps in a given power grid.

Function description:
The `evaluate_population` function is designed to assess the fitness of individuals within a population using a specified reward model. It takes two inputs: `population`, which is a list of tuples where each tuple contains a NumPy array representing an individual (specifically, its capacitor placements) and a float (initially representing a 'probe' or a placeholder fitness value); and `reward_model`, an instance of a `RewardModel` class that evaluates the fitness based on certain criteria. The function iterates through each individual in the population, calculates its fitness using the reward model based on its probe and capacitor placements, and updates the individual's fitness value accordingly. The output is a modified list of tuples, where each tuple now contains the original capacitor placements and the calculated fitness value, effectively allowing further genetic algorithm processes to utilize the fitness scores for selection and evolution.

markdown document:
```python
import numpy as np
import random
from typing import List, Tuple

def run_ga(n_pop: int, n_iter: int, n_inst: int, elite_rate: float, n_decap: int, reward_model: 'RewardModel') -> float:
    '''
    Runs the Genetic Algorithm (GA) for optimization.

    Args:
        n_pop (int): Population size.
        n_iter (int): Number of generations.
        n_inst (int): Number of test instances.
        elite_rate (float): Percentage of elite individuals.
        n_decap (int): Number of decap.
        reward_model (RewardModel): Reward model for scoring the individuals.
    '''
    sum_reward = 0.0
    for _ in range(n_inst):
        population = initialize_population(n_pop, n_decap, reward_model.n * reward_model.m)
        for _ in range(n_iter):
            population = evolve_population(population, reward_model, elite_rate)
        best_individual = min(population, key=lambda x: x[1])
        sum_reward += best_individual[1]
    return sum_reward / n_inst

def initialize_population(n_pop: int, n_decap: int, total_ports: int) -> List[Tuple[np.ndarray, float]]:
    '''
    Initializes the population with random individuals.

    Args:
        n_pop (int): Population size.
        n_decap (int): Number of decap.
        total_ports (int): Total number of ports.

    Returns:
        List[Tuple[np.ndarray, float]]: List of individuals with their fitness values.
    '''
    population = []
    for _ in range(n_pop):
        pi = np.random.choice(total_ports, n_decap, replace=False)
        probe = random.randint(0, total_ports - 1)
        population.append((pi, probe))
    return population

def evolve_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel', elite_rate: float) -> List[Tuple[np.ndarray, float]]:
    '''
    Evolves the population by selecting, mating, and mutating individuals.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.
        elite_rate (float): Percentage of elite individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: New population after evolution.
    '''
    population = evaluate_population(population, reward_model)
    elite_count = int(elite_rate * len(population))
    population.sort(key=lambda x: x[1])
    elites = population[:elite_count]
    new_population = elites.copy()
    
    while len(new_population) < len(population):
        parent1, parent2 = random.sample(elites, 2)
        child1, child2 = crossover(parent1, parent2)
        child1 = mutate(child1, reward_model.n * reward_model.m)
        child2 = mutate(child2, reward_model.n * reward_model.m)
        new_population.append(child1)
        new_population.append(child2)
    
    return new_population[:len(population)]

def evaluate_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel') -> List[Tuple[np.ndarray, float]]:
    '''
    Evaluates the population by calculating the fitness of each individual.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: Population with fitness values.
    '''
    for i in range(len(population)):
        pi, probe = population[i]
        fitness = reward_model(probe, pi)
        population[i] = (pi, fitness)
    return population

def crossover(parent1: Tuple[np.ndarray, int], parent2: Tuple[np.ndarray, int]) -> Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]:
    '''
    Performs crossover between two parents to produce two children.

    Args:
        parent1 (Tuple[np.ndarray, int]): First parent.
        parent2 (Tuple[np.ndarray, int]): Second parent.

    Returns:
        Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]: Two children.
    '''
    pi1, probe1 = parent1
    pi2, probe2 = parent2
    split_point = random.randint(1, len(pi1) - 1)
    child1_pi = np.concatenate((pi1[:split_point], pi2[split_point:]))
    child2_pi = np.concatenate((pi2[:split_point], pi1[split_point:]))
    child1_probe = probe1 if random.random() < 0.5 else probe2
    child2_probe = probe2 if random.random() < 0.5 else probe1
    return (child1_pi, child1_probe), (child2_pi, child2_probe)

def mutate(individual: Tuple[np.ndarray, int], total_ports: int) -> Tuple[np.ndarray, int]:
    '''
    Mutates an individual by randomly changing some of its genes.

    Args:
        individual (Tuple[np.ndarray, int]): Individual to mutate.
        total_ports (int): Total number of ports.

    Returns:
        Tuple[np.ndarray, int]: Mutated individual.
    '''
    pi, probe = individual
    mutation_rate = 0.1
    for i in range(len(pi)):
        if random.random() < mutation_rate:
            pi[i] = random.randint(0, total_ports - 1)
    if random.random() < mutation_rate:
        probe = random.randint(0, total_ports - 1)
    return (pi, probe)

if __name__ == "__main__":
    n, m = 10, 10
    reward_model = RewardModel(n=n, m=m)
    n_pop = 50
    n_iter = 100
    n_inst = 10
    elite_rate = 0.2
    n_decap = 10
    avg_reward = run_ga(n_pop, n_iter, n_inst, elite_rate, n_decap, reward_model)
    print(f"Average reward over {n_inst} instances: {avg_reward}")
```

### Explanation:
1. **Initialization**: The `initialize_population` function creates a population of random individuals, each with a random set of capacitor placements (`pi`) and a random probing port.
2. **Evaluation**: The `evaluate_population` function calculates the fitness of each individual using the `RewardModel`.
3. **Evolution**: The `evolve_population` function evolves the population by selecting elite individuals, performing crossover, and mutating the individuals.
4. **Crossover**: The `crossover` function combines two parents to produce two children by mixing their capacitor placements.
5. **Mutation**: The `mutate` function introduces random changes to an individual's capacitor placements and probing port.
6. **Main Function**: The `run_ga` function runs the genetic algorithm for a specified number of iterations and instances, returning the average reward.

### Test Code:
The test code initializes the `RewardModel` and runs the genetic algorithm with specified parameters, printing the average reward over multiple instances.```python
import numpy as np
import random
from typing import List, Tuple

def run_ga(n_pop: int, n_iter: int, n_inst: int, elite_rate: float, n_decap: int, reward_model: 'RewardModel') -> float:
    '''
    Runs the Genetic Algorithm (GA) for optimization.

    Args:
        n_pop (int): Population size.
        n_iter (int): Number of generations.
        n_inst (int): Number of test instances.
        elite_rate (float): Percentage of elite individuals.
        n_decap (int): Number of decap.
        reward_model (RewardModel): Reward model for scoring the individuals.
    '''
    sum_reward = 0.0
    for _ in range(n_inst):
        population = initialize_population(n_pop, n_decap, reward_model.n * reward_model.m)
        for _ in range(n_iter):
            population = evolve_population(population, reward_model, elite_rate)
        best_individual = min(population, key=lambda x: x[1])
        sum_reward += best_individual[1]
    return sum_reward / n_inst

def initialize_population(n_pop: int, n_decap: int, total_ports: int) -> List[Tuple[np.ndarray, float]]:
    '''
    Initializes the population with random individuals.

    Args:
        n_pop (int): Population size.
        n_decap (int): Number of decap.
        total_ports (int): Total number of ports.

    Returns:
        List[Tuple[np.ndarray, float]]: List of individuals with their fitness values.
    '''
    population = []
    for _ in range(n_pop):
        pi = np.random.choice(total_ports, n_decap, replace=False)
        probe = random.randint(0, total_ports - 1)
        population.append((pi, probe))
    return population

def evolve_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel', elite_rate: float) -> List[Tuple[np.ndarray, float]]:
    '''
    Evolves the population by selecting, mating, and mutating individuals.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.
        elite_rate (float): Percentage of elite individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: New population after evolution.
    '''
    population = evaluate_population(population, reward_model)
    elite_count = int(elite_rate * len(population))
    population.sort(key=lambda x: x[1])
    elites = population[:elite_count]
    new_population = elites.copy()
    
    while len(new_population) < len(population):
        parent1, parent2 = random.sample(elites, 2)
        child1, child2 = crossover(parent1, parent2)
        child1 = mutate(child1, reward_model.n * reward_model.m)
        child2 = mutate(child2, reward_model.n * reward_model.m)
        new_population.append(child1)
        new_population.append(child2)
    
    return new_population[:len(population)]

def evaluate_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel') -> List[Tuple[np.ndarray, float]]:
    '''
    Evaluates the population by calculating the fitness of each individual.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: Population with fitness values.
    '''
    for i in range(len(population)):
        pi, probe = population[i]
        fitness = reward_model(probe, pi)
        population[i] = (pi, fitness)
    return population

def crossover(parent1: Tuple[np.ndarray, int], parent2: Tuple[np.ndarray, int]) -> Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]:
    '''
    Performs crossover between two parents to produce two children.

    Args:
        parent1 (Tuple[np.ndarray, int]): First parent.
        parent2 (Tuple[np.ndarray, int]): Second parent.

    Returns:
        Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]: Two children.
    '''
    pi1, probe1 = parent1
    pi2, probe2 = parent2
    split_point = random.randint(1, len(pi1) - 1)
    child1_pi = np.concatenate((pi1[:split_point], pi2[split_point:]))
    child2_pi = np.concatenate((pi2[:split_point], pi1[split_point:]))
    child1_probe = probe1 if random.random() < 0.5 else probe2
    child2_probe = probe2 if random.random() < 0.5 else probe1
    return (child1_pi, child1_probe), (child2_pi, child2_probe)

def mutate(individual: Tuple[np.ndarray, int], total_ports: int) -> Tuple[np.ndarray, int]:
    '''
    Mutates an individual by randomly changing some of its genes.

    Args:
        individual (Tuple[np.ndarray, int]): Individual to mutate.
        total_ports (int): Total number of ports.

    Returns:
        Tuple[np.ndarray, int]: Mutated individual.
    '''
    pi, probe = individual
    mutation_rate = 0.1
    for i in range(len(pi)):
        if random.random() < mutation_rate:
            pi[i] = random.randint(0, total_ports - 1)
    if random.random() < mutation_rate:
        probe = random.randint(0, total_ports - 1)
    return (pi, probe)

if __name__ == "__main__":
    n, m = 10, 10
    reward_model = RewardModel(n=n, m=m)
    n_pop = 50
    n_iter = 100
    n_inst = 10
    elite_rate = 0.2
    n_decap = 10
    avg_reward = run_ga(n_pop, n_iter, n_inst, elite_rate, n_decap, reward_model)
    print(f"Average reward over {n_inst} instances: {avg_reward}")
```

### Explanation:
1. **Initialization**: The `initialize_population` function creates a population of random individuals, each with a random set of capacitor placements (`pi`) and a random probing port.
2. **Evaluation**: The `evaluate_population` function calculates the fitness of each individual using the `RewardModel`.
3. **Evolution**: The `evolve_population` function evolves the population by selecting elite individuals, performing crossover, and mutating the individuals.
4. **Crossover**: The `crossover` function combines two parents to produce two children by mixing their capacitor placements.
5. **Mutation**: The `mutate` function introduces random changes to an individual's capacitor placements and probing port.
6. **Main Function**: The `run_ga` function runs the genetic algorithm for a specified number of iterations and instances, returning the average reward.

### Test Code:
The test code initializes the `RewardModel` and runs the genetic algorithm with specified parameters, printing the average reward over multiple instances.

```python
def evaluate_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel') -> List[Tuple[np.ndarray, float]]:
    '''
    Evaluates the population by calculating the fitness of each individual.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: Population with fitness values.
    '''
    for i in range(len(population)):
        pi, probe = population[i]
        fitness = reward_model(probe, pi)
        population[i] = (pi, fitness)
    return population

```

Refer to the format of a trivial design above. Be very creative and give `evaluate_population_v2`. Output code only and enclose your code with Python code block: ```python ... ```.


[2024-11-28 22:48:10,992][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-28 22:48:11,105][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-28 22:48:11,492][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-28 22:48:26,820][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are an expert-level algorithm engineer. Your task is to design efficient algorithms that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
There is a Markdown document that contains Python code along with relevant explanations. A target function `crossover` has been selected from this document.
Write a new `crossover` for problem:
Assisting in solving black-box decap placement problem with genetic algorithm. The problem requires finding the optimal placement of decaps in a given power grid.

Function description:
The `crossover` function is designed to facilitate genetic mixing in a genetic algorithm by taking two parent tuples as inputs, where each tuple consists of a NumPy array representing capacitor placements and an integer representing a probing port. The function randomly selects a split point to create two children: `child1` and `child2`, where each child's capacitor placements are formed by combining the initial segments from one parent with the latter segments from the other. Additionally, each child is assigned a probing port chosen randomly from one of the parents. The output of the function is a tuple containing the two children, each structured similarly to the parent input tuples. The primary purpose of this function is to breed new individuals that inherit traits from both parents, thereby enhancing the exploration of the search space in the optimization process.

markdown document:
```python
import numpy as np
import random
from typing import List, Tuple

def run_ga(n_pop: int, n_iter: int, n_inst: int, elite_rate: float, n_decap: int, reward_model: 'RewardModel') -> float:
    '''
    Runs the Genetic Algorithm (GA) for optimization.

    Args:
        n_pop (int): Population size.
        n_iter (int): Number of generations.
        n_inst (int): Number of test instances.
        elite_rate (float): Percentage of elite individuals.
        n_decap (int): Number of decap.
        reward_model (RewardModel): Reward model for scoring the individuals.
    '''
    sum_reward = 0.0
    for _ in range(n_inst):
        population = initialize_population(n_pop, n_decap, reward_model.n * reward_model.m)
        for _ in range(n_iter):
            population = evolve_population(population, reward_model, elite_rate)
        best_individual = min(population, key=lambda x: x[1])
        sum_reward += best_individual[1]
    return sum_reward / n_inst

def initialize_population(n_pop: int, n_decap: int, total_ports: int) -> List[Tuple[np.ndarray, float]]:
    '''
    Initializes the population with random individuals.

    Args:
        n_pop (int): Population size.
        n_decap (int): Number of decap.
        total_ports (int): Total number of ports.

    Returns:
        List[Tuple[np.ndarray, float]]: List of individuals with their fitness values.
    '''
    population = []
    for _ in range(n_pop):
        pi = np.random.choice(total_ports, n_decap, replace=False)
        probe = random.randint(0, total_ports - 1)
        population.append((pi, probe))
    return population

def evolve_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel', elite_rate: float) -> List[Tuple[np.ndarray, float]]:
    '''
    Evolves the population by selecting, mating, and mutating individuals.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.
        elite_rate (float): Percentage of elite individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: New population after evolution.
    '''
    population = evaluate_population(population, reward_model)
    elite_count = int(elite_rate * len(population))
    population.sort(key=lambda x: x[1])
    elites = population[:elite_count]
    new_population = elites.copy()
    
    while len(new_population) < len(population):
        parent1, parent2 = random.sample(elites, 2)
        child1, child2 = crossover(parent1, parent2)
        child1 = mutate(child1, reward_model.n * reward_model.m)
        child2 = mutate(child2, reward_model.n * reward_model.m)
        new_population.append(child1)
        new_population.append(child2)
    
    return new_population[:len(population)]

def evaluate_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel') -> List[Tuple[np.ndarray, float]]:
    '''
    Evaluates the population by calculating the fitness of each individual.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: Population with fitness values.
    '''
    for i in range(len(population)):
        pi, probe = population[i]
        fitness = reward_model(probe, pi)
        population[i] = (pi, fitness)
    return population

def crossover(parent1: Tuple[np.ndarray, int], parent2: Tuple[np.ndarray, int]) -> Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]:
    '''
    Performs crossover between two parents to produce two children.

    Args:
        parent1 (Tuple[np.ndarray, int]): First parent.
        parent2 (Tuple[np.ndarray, int]): Second parent.

    Returns:
        Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]: Two children.
    '''
    pi1, probe1 = parent1
    pi2, probe2 = parent2
    split_point = random.randint(1, len(pi1) - 1)
    child1_pi = np.concatenate((pi1[:split_point], pi2[split_point:]))
    child2_pi = np.concatenate((pi2[:split_point], pi1[split_point:]))
    child1_probe = probe1 if random.random() < 0.5 else probe2
    child2_probe = probe2 if random.random() < 0.5 else probe1
    return (child1_pi, child1_probe), (child2_pi, child2_probe)

def mutate(individual: Tuple[np.ndarray, int], total_ports: int) -> Tuple[np.ndarray, int]:
    '''
    Mutates an individual by randomly changing some of its genes.

    Args:
        individual (Tuple[np.ndarray, int]): Individual to mutate.
        total_ports (int): Total number of ports.

    Returns:
        Tuple[np.ndarray, int]: Mutated individual.
    '''
    pi, probe = individual
    mutation_rate = 0.1
    for i in range(len(pi)):
        if random.random() < mutation_rate:
            pi[i] = random.randint(0, total_ports - 1)
    if random.random() < mutation_rate:
        probe = random.randint(0, total_ports - 1)
    return (pi, probe)

if __name__ == "__main__":
    n, m = 10, 10
    reward_model = RewardModel(n=n, m=m)
    n_pop = 50
    n_iter = 100
    n_inst = 10
    elite_rate = 0.2
    n_decap = 10
    avg_reward = run_ga(n_pop, n_iter, n_inst, elite_rate, n_decap, reward_model)
    print(f"Average reward over {n_inst} instances: {avg_reward}")
```

### Explanation:
1. **Initialization**: The `initialize_population` function creates a population of random individuals, each with a random set of capacitor placements (`pi`) and a random probing port.
2. **Evaluation**: The `evaluate_population` function calculates the fitness of each individual using the `RewardModel`.
3. **Evolution**: The `evolve_population` function evolves the population by selecting elite individuals, performing crossover, and mutating the individuals.
4. **Crossover**: The `crossover` function combines two parents to produce two children by mixing their capacitor placements.
5. **Mutation**: The `mutate` function introduces random changes to an individual's capacitor placements and probing port.
6. **Main Function**: The `run_ga` function runs the genetic algorithm for a specified number of iterations and instances, returning the average reward.

### Test Code:
The test code initializes the `RewardModel` and runs the genetic algorithm with specified parameters, printing the average reward over multiple instances.```python
import numpy as np
import random
from typing import List, Tuple

def run_ga(n_pop: int, n_iter: int, n_inst: int, elite_rate: float, n_decap: int, reward_model: 'RewardModel') -> float:
    '''
    Runs the Genetic Algorithm (GA) for optimization.

    Args:
        n_pop (int): Population size.
        n_iter (int): Number of generations.
        n_inst (int): Number of test instances.
        elite_rate (float): Percentage of elite individuals.
        n_decap (int): Number of decap.
        reward_model (RewardModel): Reward model for scoring the individuals.
    '''
    sum_reward = 0.0
    for _ in range(n_inst):
        population = initialize_population(n_pop, n_decap, reward_model.n * reward_model.m)
        for _ in range(n_iter):
            population = evolve_population(population, reward_model, elite_rate)
        best_individual = min(population, key=lambda x: x[1])
        sum_reward += best_individual[1]
    return sum_reward / n_inst

def initialize_population(n_pop: int, n_decap: int, total_ports: int) -> List[Tuple[np.ndarray, float]]:
    '''
    Initializes the population with random individuals.

    Args:
        n_pop (int): Population size.
        n_decap (int): Number of decap.
        total_ports (int): Total number of ports.

    Returns:
        List[Tuple[np.ndarray, float]]: List of individuals with their fitness values.
    '''
    population = []
    for _ in range(n_pop):
        pi = np.random.choice(total_ports, n_decap, replace=False)
        probe = random.randint(0, total_ports - 1)
        population.append((pi, probe))
    return population

def evolve_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel', elite_rate: float) -> List[Tuple[np.ndarray, float]]:
    '''
    Evolves the population by selecting, mating, and mutating individuals.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.
        elite_rate (float): Percentage of elite individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: New population after evolution.
    '''
    population = evaluate_population(population, reward_model)
    elite_count = int(elite_rate * len(population))
    population.sort(key=lambda x: x[1])
    elites = population[:elite_count]
    new_population = elites.copy()
    
    while len(new_population) < len(population):
        parent1, parent2 = random.sample(elites, 2)
        child1, child2 = crossover(parent1, parent2)
        child1 = mutate(child1, reward_model.n * reward_model.m)
        child2 = mutate(child2, reward_model.n * reward_model.m)
        new_population.append(child1)
        new_population.append(child2)
    
    return new_population[:len(population)]

def evaluate_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel') -> List[Tuple[np.ndarray, float]]:
    '''
    Evaluates the population by calculating the fitness of each individual.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: Population with fitness values.
    '''
    for i in range(len(population)):
        pi, probe = population[i]
        fitness = reward_model(probe, pi)
        population[i] = (pi, fitness)
    return population

def crossover(parent1: Tuple[np.ndarray, int], parent2: Tuple[np.ndarray, int]) -> Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]:
    '''
    Performs crossover between two parents to produce two children.

    Args:
        parent1 (Tuple[np.ndarray, int]): First parent.
        parent2 (Tuple[np.ndarray, int]): Second parent.

    Returns:
        Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]: Two children.
    '''
    pi1, probe1 = parent1
    pi2, probe2 = parent2
    split_point = random.randint(1, len(pi1) - 1)
    child1_pi = np.concatenate((pi1[:split_point], pi2[split_point:]))
    child2_pi = np.concatenate((pi2[:split_point], pi1[split_point:]))
    child1_probe = probe1 if random.random() < 0.5 else probe2
    child2_probe = probe2 if random.random() < 0.5 else probe1
    return (child1_pi, child1_probe), (child2_pi, child2_probe)

def mutate(individual: Tuple[np.ndarray, int], total_ports: int) -> Tuple[np.ndarray, int]:
    '''
    Mutates an individual by randomly changing some of its genes.

    Args:
        individual (Tuple[np.ndarray, int]): Individual to mutate.
        total_ports (int): Total number of ports.

    Returns:
        Tuple[np.ndarray, int]: Mutated individual.
    '''
    pi, probe = individual
    mutation_rate = 0.1
    for i in range(len(pi)):
        if random.random() < mutation_rate:
            pi[i] = random.randint(0, total_ports - 1)
    if random.random() < mutation_rate:
        probe = random.randint(0, total_ports - 1)
    return (pi, probe)

if __name__ == "__main__":
    n, m = 10, 10
    reward_model = RewardModel(n=n, m=m)
    n_pop = 50
    n_iter = 100
    n_inst = 10
    elite_rate = 0.2
    n_decap = 10
    avg_reward = run_ga(n_pop, n_iter, n_inst, elite_rate, n_decap, reward_model)
    print(f"Average reward over {n_inst} instances: {avg_reward}")
```

### Explanation:
1. **Initialization**: The `initialize_population` function creates a population of random individuals, each with a random set of capacitor placements (`pi`) and a random probing port.
2. **Evaluation**: The `evaluate_population` function calculates the fitness of each individual using the `RewardModel`.
3. **Evolution**: The `evolve_population` function evolves the population by selecting elite individuals, performing crossover, and mutating the individuals.
4. **Crossover**: The `crossover` function combines two parents to produce two children by mixing their capacitor placements.
5. **Mutation**: The `mutate` function introduces random changes to an individual's capacitor placements and probing port.
6. **Main Function**: The `run_ga` function runs the genetic algorithm for a specified number of iterations and instances, returning the average reward.

### Test Code:
The test code initializes the `RewardModel` and runs the genetic algorithm with specified parameters, printing the average reward over multiple instances.

```python
def crossover(parent1: Tuple[np.ndarray, int], parent2: Tuple[np.ndarray, int]) -> Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]:
    '''
    Performs crossover between two parents to produce two children.

    Args:
        parent1 (Tuple[np.ndarray, int]): First parent.
        parent2 (Tuple[np.ndarray, int]): Second parent.

    Returns:
        Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]: Two children.
    '''
    pi1, probe1 = parent1
    pi2, probe2 = parent2
    split_point = random.randint(1, len(pi1) - 1)
    child1_pi = np.concatenate((pi1[:split_point], pi2[split_point:]))
    child2_pi = np.concatenate((pi2[:split_point], pi1[split_point:]))
    child1_probe = probe1 if random.random() < 0.5 else probe2
    child2_probe = probe2 if random.random() < 0.5 else probe1
    return (child1_pi, child1_probe), (child2_pi, child2_probe)

```

Refer to the format of a trivial design above. Be very creative and give `crossover_v2`. Output code only and enclose your code with Python code block: ```python ... ```.


[2024-11-28 22:48:27,144][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-28 22:48:27,406][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-28 22:48:27,476][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-28 22:48:55,336][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are an expert-level algorithm engineer. Your task is to design efficient algorithms that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
There is a Markdown document that contains Python code along with relevant explanations. A target function `mutate` has been selected from this document.
Write a new `mutate` for problem:
Assisting in solving black-box decap placement problem with genetic algorithm. The problem requires finding the optimal placement of decaps in a given power grid.

Function description:
The `mutate` function is designed to introduce genetic diversity into an individual within a genetic algorithm by randomly modifying some of its attributes, referred to as genes. It takes as inputs a tuple representing the individual, consisting of an array (which contains a set of capacitor placements labeled as `pi`) and an integer (`probe`), along with `total_ports`, which indicates the maximum range of possible values for the genes. The function outputs a modified individual (as a tuple) where each element of the `pi` array is subject to mutation based on a defined mutation rate, and the `probe` value may also be altered randomly. The primary purpose of this function is to enhance the variability of the population, allowing for exploration of a broader solution space during the optimization process.

markdown document:
```python
import numpy as np
import random
from typing import List, Tuple

def run_ga(n_pop: int, n_iter: int, n_inst: int, elite_rate: float, n_decap: int, reward_model: 'RewardModel') -> float:
    '''
    Runs the Genetic Algorithm (GA) for optimization.

    Args:
        n_pop (int): Population size.
        n_iter (int): Number of generations.
        n_inst (int): Number of test instances.
        elite_rate (float): Percentage of elite individuals.
        n_decap (int): Number of decap.
        reward_model (RewardModel): Reward model for scoring the individuals.
    '''
    sum_reward = 0.0
    for _ in range(n_inst):
        population = initialize_population(n_pop, n_decap, reward_model.n * reward_model.m)
        for _ in range(n_iter):
            population = evolve_population(population, reward_model, elite_rate)
        best_individual = min(population, key=lambda x: x[1])
        sum_reward += best_individual[1]
    return sum_reward / n_inst

def initialize_population(n_pop: int, n_decap: int, total_ports: int) -> List[Tuple[np.ndarray, float]]:
    '''
    Initializes the population with random individuals.

    Args:
        n_pop (int): Population size.
        n_decap (int): Number of decap.
        total_ports (int): Total number of ports.

    Returns:
        List[Tuple[np.ndarray, float]]: List of individuals with their fitness values.
    '''
    population = []
    for _ in range(n_pop):
        pi = np.random.choice(total_ports, n_decap, replace=False)
        probe = random.randint(0, total_ports - 1)
        population.append((pi, probe))
    return population

def evolve_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel', elite_rate: float) -> List[Tuple[np.ndarray, float]]:
    '''
    Evolves the population by selecting, mating, and mutating individuals.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.
        elite_rate (float): Percentage of elite individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: New population after evolution.
    '''
    population = evaluate_population(population, reward_model)
    elite_count = int(elite_rate * len(population))
    population.sort(key=lambda x: x[1])
    elites = population[:elite_count]
    new_population = elites.copy()
    
    while len(new_population) < len(population):
        parent1, parent2 = random.sample(elites, 2)
        child1, child2 = crossover(parent1, parent2)
        child1 = mutate(child1, reward_model.n * reward_model.m)
        child2 = mutate(child2, reward_model.n * reward_model.m)
        new_population.append(child1)
        new_population.append(child2)
    
    return new_population[:len(population)]

def evaluate_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel') -> List[Tuple[np.ndarray, float]]:
    '''
    Evaluates the population by calculating the fitness of each individual.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: Population with fitness values.
    '''
    for i in range(len(population)):
        pi, probe = population[i]
        fitness = reward_model(probe, pi)
        population[i] = (pi, fitness)
    return population

def crossover(parent1: Tuple[np.ndarray, int], parent2: Tuple[np.ndarray, int]) -> Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]:
    '''
    Performs crossover between two parents to produce two children.

    Args:
        parent1 (Tuple[np.ndarray, int]): First parent.
        parent2 (Tuple[np.ndarray, int]): Second parent.

    Returns:
        Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]: Two children.
    '''
    pi1, probe1 = parent1
    pi2, probe2 = parent2
    split_point = random.randint(1, len(pi1) - 1)
    child1_pi = np.concatenate((pi1[:split_point], pi2[split_point:]))
    child2_pi = np.concatenate((pi2[:split_point], pi1[split_point:]))
    child1_probe = probe1 if random.random() < 0.5 else probe2
    child2_probe = probe2 if random.random() < 0.5 else probe1
    return (child1_pi, child1_probe), (child2_pi, child2_probe)

def mutate(individual: Tuple[np.ndarray, int], total_ports: int) -> Tuple[np.ndarray, int]:
    '''
    Mutates an individual by randomly changing some of its genes.

    Args:
        individual (Tuple[np.ndarray, int]): Individual to mutate.
        total_ports (int): Total number of ports.

    Returns:
        Tuple[np.ndarray, int]: Mutated individual.
    '''
    pi, probe = individual
    mutation_rate = 0.1
    for i in range(len(pi)):
        if random.random() < mutation_rate:
            pi[i] = random.randint(0, total_ports - 1)
    if random.random() < mutation_rate:
        probe = random.randint(0, total_ports - 1)
    return (pi, probe)

if __name__ == "__main__":
    n, m = 10, 10
    reward_model = RewardModel(n=n, m=m)
    n_pop = 50
    n_iter = 100
    n_inst = 10
    elite_rate = 0.2
    n_decap = 10
    avg_reward = run_ga(n_pop, n_iter, n_inst, elite_rate, n_decap, reward_model)
    print(f"Average reward over {n_inst} instances: {avg_reward}")
```

### Explanation:
1. **Initialization**: The `initialize_population` function creates a population of random individuals, each with a random set of capacitor placements (`pi`) and a random probing port.
2. **Evaluation**: The `evaluate_population` function calculates the fitness of each individual using the `RewardModel`.
3. **Evolution**: The `evolve_population` function evolves the population by selecting elite individuals, performing crossover, and mutating the individuals.
4. **Crossover**: The `crossover` function combines two parents to produce two children by mixing their capacitor placements.
5. **Mutation**: The `mutate` function introduces random changes to an individual's capacitor placements and probing port.
6. **Main Function**: The `run_ga` function runs the genetic algorithm for a specified number of iterations and instances, returning the average reward.

### Test Code:
The test code initializes the `RewardModel` and runs the genetic algorithm with specified parameters, printing the average reward over multiple instances.```python
import numpy as np
import random
from typing import List, Tuple

def run_ga(n_pop: int, n_iter: int, n_inst: int, elite_rate: float, n_decap: int, reward_model: 'RewardModel') -> float:
    '''
    Runs the Genetic Algorithm (GA) for optimization.

    Args:
        n_pop (int): Population size.
        n_iter (int): Number of generations.
        n_inst (int): Number of test instances.
        elite_rate (float): Percentage of elite individuals.
        n_decap (int): Number of decap.
        reward_model (RewardModel): Reward model for scoring the individuals.
    '''
    sum_reward = 0.0
    for _ in range(n_inst):
        population = initialize_population(n_pop, n_decap, reward_model.n * reward_model.m)
        for _ in range(n_iter):
            population = evolve_population(population, reward_model, elite_rate)
        best_individual = min(population, key=lambda x: x[1])
        sum_reward += best_individual[1]
    return sum_reward / n_inst

def initialize_population(n_pop: int, n_decap: int, total_ports: int) -> List[Tuple[np.ndarray, float]]:
    '''
    Initializes the population with random individuals.

    Args:
        n_pop (int): Population size.
        n_decap (int): Number of decap.
        total_ports (int): Total number of ports.

    Returns:
        List[Tuple[np.ndarray, float]]: List of individuals with their fitness values.
    '''
    population = []
    for _ in range(n_pop):
        pi = np.random.choice(total_ports, n_decap, replace=False)
        probe = random.randint(0, total_ports - 1)
        population.append((pi, probe))
    return population

def evolve_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel', elite_rate: float) -> List[Tuple[np.ndarray, float]]:
    '''
    Evolves the population by selecting, mating, and mutating individuals.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.
        elite_rate (float): Percentage of elite individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: New population after evolution.
    '''
    population = evaluate_population(population, reward_model)
    elite_count = int(elite_rate * len(population))
    population.sort(key=lambda x: x[1])
    elites = population[:elite_count]
    new_population = elites.copy()
    
    while len(new_population) < len(population):
        parent1, parent2 = random.sample(elites, 2)
        child1, child2 = crossover(parent1, parent2)
        child1 = mutate(child1, reward_model.n * reward_model.m)
        child2 = mutate(child2, reward_model.n * reward_model.m)
        new_population.append(child1)
        new_population.append(child2)
    
    return new_population[:len(population)]

def evaluate_population(population: List[Tuple[np.ndarray, float]], reward_model: 'RewardModel') -> List[Tuple[np.ndarray, float]]:
    '''
    Evaluates the population by calculating the fitness of each individual.

    Args:
        population (List[Tuple[np.ndarray, float]]): Current population.
        reward_model (RewardModel): Reward model for scoring the individuals.

    Returns:
        List[Tuple[np.ndarray, float]]: Population with fitness values.
    '''
    for i in range(len(population)):
        pi, probe = population[i]
        fitness = reward_model(probe, pi)
        population[i] = (pi, fitness)
    return population

def crossover(parent1: Tuple[np.ndarray, int], parent2: Tuple[np.ndarray, int]) -> Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]:
    '''
    Performs crossover between two parents to produce two children.

    Args:
        parent1 (Tuple[np.ndarray, int]): First parent.
        parent2 (Tuple[np.ndarray, int]): Second parent.

    Returns:
        Tuple[Tuple[np.ndarray, int], Tuple[np.ndarray, int]]: Two children.
    '''
    pi1, probe1 = parent1
    pi2, probe2 = parent2
    split_point = random.randint(1, len(pi1) - 1)
    child1_pi = np.concatenate((pi1[:split_point], pi2[split_point:]))
    child2_pi = np.concatenate((pi2[:split_point], pi1[split_point:]))
    child1_probe = probe1 if random.random() < 0.5 else probe2
    child2_probe = probe2 if random.random() < 0.5 else probe1
    return (child1_pi, child1_probe), (child2_pi, child2_probe)

def mutate(individual: Tuple[np.ndarray, int], total_ports: int) -> Tuple[np.ndarray, int]:
    '''
    Mutates an individual by randomly changing some of its genes.

    Args:
        individual (Tuple[np.ndarray, int]): Individual to mutate.
        total_ports (int): Total number of ports.

    Returns:
        Tuple[np.ndarray, int]: Mutated individual.
    '''
    pi, probe = individual
    mutation_rate = 0.1
    for i in range(len(pi)):
        if random.random() < mutation_rate:
            pi[i] = random.randint(0, total_ports - 1)
    if random.random() < mutation_rate:
        probe = random.randint(0, total_ports - 1)
    return (pi, probe)

if __name__ == "__main__":
    n, m = 10, 10
    reward_model = RewardModel(n=n, m=m)
    n_pop = 50
    n_iter = 100
    n_inst = 10
    elite_rate = 0.2
    n_decap = 10
    avg_reward = run_ga(n_pop, n_iter, n_inst, elite_rate, n_decap, reward_model)
    print(f"Average reward over {n_inst} instances: {avg_reward}")
```

### Explanation:
1. **Initialization**: The `initialize_population` function creates a population of random individuals, each with a random set of capacitor placements (`pi`) and a random probing port.
2. **Evaluation**: The `evaluate_population` function calculates the fitness of each individual using the `RewardModel`.
3. **Evolution**: The `evolve_population` function evolves the population by selecting elite individuals, performing crossover, and mutating the individuals.
4. **Crossover**: The `crossover` function combines two parents to produce two children by mixing their capacitor placements.
5. **Mutation**: The `mutate` function introduces random changes to an individual's capacitor placements and probing port.
6. **Main Function**: The `run_ga` function runs the genetic algorithm for a specified number of iterations and instances, returning the average reward.

### Test Code:
The test code initializes the `RewardModel` and runs the genetic algorithm with specified parameters, printing the average reward over multiple instances.

```python
def mutate(individual: Tuple[np.ndarray, int], total_ports: int) -> Tuple[np.ndarray, int]:
    '''
    Mutates an individual by randomly changing some of its genes.

    Args:
        individual (Tuple[np.ndarray, int]): Individual to mutate.
        total_ports (int): Total number of ports.

    Returns:
        Tuple[np.ndarray, int]: Mutated individual.
    '''
    pi, probe = individual
    mutation_rate = 0.1
    for i in range(len(pi)):
        if random.random() < mutation_rate:
            pi[i] = random.randint(0, total_ports - 1)
    if random.random() < mutation_rate:
        probe = random.randint(0, total_ports - 1)
    return (pi, probe)

```

Refer to the format of a trivial design above. Be very creative and give `mutate_v2`. Output code only and enclose your code with Python code block: ```python ... ```.


[2024-11-28 22:48:55,746][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-28 22:48:56,346][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-28 22:48:56,359][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-28 22:49:19,537][root][INFO] - Iteration 1: Running Code 0
[2024-11-28 22:49:19,990][root][INFO] - Iteration 1: Code Run 0 successful!
[2024-11-28 22:49:19,991][root][INFO] - Iteration 1: Running Code 1
[2024-11-28 22:49:20,430][root][INFO] - Iteration 1: Code Run 1 successful!
[2024-11-28 22:49:20,431][root][INFO] - Iteration 1: Running Code 2
[2024-11-28 22:49:21,209][root][INFO] - Iteration 1: Code Run 2 successful!
[2024-11-28 22:49:21,209][root][INFO] - Iteration 1: Running Code 3
[2024-11-28 22:49:23,921][root][INFO] - Iteration 1: Code Run 3 successful!
[2024-11-28 22:49:23,924][root][INFO] - Iteration 1: Running Code 4
[2024-11-28 22:49:28,335][root][INFO] - Iteration 1: Code Run 4 successful!
[2024-11-28 22:49:28,336][root][INFO] - Iteration 1: Running Code 5
[2024-11-28 22:49:33,203][root][INFO] - Iteration 1: Code Run 5 successful!
[2024-11-28 22:49:33,212][root][INFO] - Iteration 1: Running Code 6
[2024-11-28 22:49:41,773][root][INFO] - Iteration 1: Code Run 6 successful!
[2024-11-28 22:49:41,854][root][INFO] - Iteration 1: Running Code 7
[2024-11-28 22:49:51,819][root][INFO] - Iteration 1: Code Run 7 successful!
[2024-11-28 22:49:51,849][root][INFO] - Iteration 1: Running Code 8
[2024-11-28 22:50:01,018][root][INFO] - Iteration 1: Code Run 8 successful!
[2024-11-28 22:50:01,130][root][INFO] - Iteration 1: Running Code 9
[2024-11-28 22:50:08,379][root][INFO] - Iteration 1: Code Run 9 successful!
[2024-11-28 22:50:08,379][root][INFO] - Iteration 1: Running Code 10
[2024-11-28 22:50:16,198][root][INFO] - Iteration 1: Code Run 10 successful!
[2024-11-28 22:50:16,199][root][INFO] - Iteration 1: Running Code 11
[2024-11-28 22:50:22,253][root][INFO] - Iteration 1: Code Run 11 successful!
[2024-11-28 22:50:22,559][root][INFO] - Iteration 1: Running Code 12
[2024-11-28 22:50:35,989][root][INFO] - Iteration 1: Code Run 12 successful!
[2024-11-28 22:50:36,066][root][INFO] - Iteration 1: Running Code 13
[2024-11-28 22:50:45,962][root][INFO] - Iteration 1: Code Run 13 successful!
[2024-11-28 22:50:46,291][root][INFO] - Iteration 1: Running Code 14
[2024-11-28 22:50:59,513][root][INFO] - Iteration 1: Code Run 14 successful!
[2024-11-28 22:50:59,514][root][INFO] - Iteration 1: Running Code 15
[2024-11-28 22:51:06,685][root][INFO] - Iteration 1: Code Run 15 successful!
[2024-11-28 22:51:07,077][root][INFO] - Iteration 1: Running Code 16
[2024-11-28 22:51:19,113][root][INFO] - Iteration 1: Code Run 16 successful!
[2024-11-28 22:51:19,113][root][INFO] - Iteration 1: Running Code 17
[2024-11-28 22:51:32,272][root][INFO] - Iteration 1: Code Run 17 successful!
[2024-11-28 22:56:32,286][root][INFO] - Error for response_id 0: Command '['python', '-u', 'E:\\all_works\\iclr2025\\AEL-P-SNE(1)\\AEL-P-SNE/problems/dpp_ga/eval.py', '0', 'E:\\all_works\\iclr2025\\AEL-P-SNE(1)\\AEL-P-SNE', 'train', 'iter_num_1_func_index_0_response_id_0.py']' timed out after 300.0 seconds
[2024-11-28 23:01:32,286][root][INFO] - Error for response_id 1: Command '['python', '-u', 'E:\\all_works\\iclr2025\\AEL-P-SNE(1)\\AEL-P-SNE/problems/dpp_ga/eval.py', '0', 'E:\\all_works\\iclr2025\\AEL-P-SNE(1)\\AEL-P-SNE', 'train', 'iter_num_1_func_index_0_response_id_1.py']' timed out after 300.0 seconds
