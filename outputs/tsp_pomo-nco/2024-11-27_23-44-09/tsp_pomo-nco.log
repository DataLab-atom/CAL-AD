[2024-11-27 23:44:09,427][root][INFO] - Workspace: e:\all_works\iclr2025\AEL-P-SNE(1)\AEL-P-SNE\outputs\tsp_pomo-nco\2024-11-27_23-44-09
[2024-11-27 23:44:09,428][root][INFO] - Project Root: e:\all_works\iclr2025\AEL-P-SNE(1)\AEL-P-SNE
[2024-11-27 23:44:09,428][root][INFO] - Using LLM: deepseek-coder
[2024-11-27 23:44:09,428][root][INFO] - Using Algorithm: reevo
[2024-11-27 23:44:11,437][root][INFO] - Problem: tsp_pomo
[2024-11-27 23:44:11,438][root][INFO] - Problem description: Assisting in solving the Traveling Salesman Problem (TSP) with some prior heuristics. TSP requires finding the shortest path that visits all given nodes and returns to the starting node.
[2024-11-27 23:44:11,439][root][INFO] - Functions name: [initialize_population,calculate_fitness,select_parents,crossover,mutate,search_routine]
[2024-11-27 23:44:11,444][root][INFO] - Functions name in Iter: [crossover]
[2024-11-27 23:44:11,447][root][INFO] - Evaluating seed function...
[2024-11-27 23:44:11,448][root][INFO] - Seed function code: 
from numpy.linalg import inv, norm, pinv
import random
from typing import Callable
from typing import Tuple
import numpy as np
def initialize_population(num_points: int, pop_size: int) -> np.ndarray:
    """
    Initialize a population of random routes.
    
    Parameters:
    - num_points: int, number of points in the TSP.
    - pop_size: int, size of the population.
    
    Returns:
    - np.ndarray, population of routes.
    """
    population = [np.random.permutation(num_points) for _ in range(pop_size)]
    return np.array(population)
def calculate_fitness(population: np.ndarray, distance_matrix: np.ndarray, cal_total_distance: Callable) -> np.ndarray:
    """
    Calculate the fitness (total distance) for each route in the population.
    
    Parameters:
    - population: np.ndarray, population of routes.
    - distance_matrix: np.ndarray, distance matrix.
    - cal_total_distance: Callable, function to calculate total distance.
    
    Returns:
    - np.ndarray, fitness values for each route.
    """
    fitness = np.array([cal_total_distance(route, distance_matrix) for route in population])
    return fitness
def select_parents(population: np.ndarray, fitness: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    """
    Select parents based on fitness using roulette wheel selection.
    
    Parameters:
    - population: np.ndarray, population of routes.
    - fitness: np.ndarray, fitness values for each route.
    
    Returns:
    - Tuple[np.ndarray, np.ndarray], selected parents.
    """
    fitness = 1 / fitness  # Invert fitness to get higher values for better routes
    fitness_sum = np.sum(fitness)
    probabilities = fitness / fitness_sum
    indices = np.random.choice(len(population), size=2, p=probabilities, replace=False)
    return population[indices[0]], population[indices[1]]
def crossover(parent1: np.ndarray, parent2: np.ndarray) -> np.ndarray:
    """
    Perform ordered crossover to create a child route.
    
    Parameters:
    - parent1: np.ndarray, first parent route.
    - parent2: np.ndarray, second parent route.
    
    Returns:
    - np.ndarray, child route.
    """
    size = len(parent1)
    start, end = sorted(np.random.choice(size, 2, replace=False))
    child = np.zeros(size, dtype=int)
    child[start:end] = parent1[start:end]
    for i in range(size):
        if parent2[i] not in child:
            for j in range(size):
                if child[j] == 0:
                    child[j] = parent2[i]
                    break
    return child
def mutate(route: np.ndarray, mutation_rate: float) -> np.ndarray:
    """
    Mutate a route by swapping two points with a given mutation rate.
    
    Parameters:
    - route: np.ndarray, route to mutate.
    - mutation_rate: float, probability of mutation.
    
    Returns:
    - np.ndarray, mutated route.
    """
    if np.random.rand() < mutation_rate:
        idx1, idx2 = np.random.choice(len(route), 2, replace=False)
        route[idx1], route[idx2] = route[idx2], route[idx1]
    return route
def search_routine(cal_total_distance: Callable, distance_matrix: np.ndarray, pop_size: int = 100, num_generations: int = 1000, mutation_rate: float = 0.01) -> np.ndarray:
    """
    Perform the POMO algorithm to find the optimal route.
    
    Parameters:
    - cal_total_distance: Callable, function to calculate total distance.
    - distance_matrix: np.ndarray, distance matrix.
    - pop_size: int, size of the population.
    - num_generations: int, number of generations to run the algorithm.
    - mutation_rate: float, probability of mutation.
    
    Returns:
    - np.ndarray, best route found.
    """
    num_points = distance_matrix.shape[0]
    population = initialize_population(num_points, pop_size)
    
    for generation in range(num_generations):
        fitness = calculate_fitness(population, distance_matrix, cal_total_distance)
        new_population = []
        
        for _ in range(pop_size // 2):
            parent1, parent2 = select_parents(population, fitness)
            child1 = crossover(parent1, parent2)
            child2 = crossover(parent2, parent1)
            child1 = mutate(child1, mutation_rate)
            child2 = mutate(child2, mutation_rate)
            new_population.append(child1)
            new_population.append(child2)
        
        population = np.array(new_population)
    
    best_ind = population[np.argmin(calculate_fitness(population, distance_matrix, cal_total_distance))]
    return best_ind
[2024-11-27 23:44:11,459][root][INFO] - Iteration 0: Running Code 0
[2024-11-27 23:44:11,815][root][INFO] - Iteration 0: Code Run 0 successful!
[2024-11-27 23:44:57,249][root][INFO] - Iteration 0, response_id 0: Objective value: 102.09947734325718
[2024-11-27 23:44:57,250][root][INFO] - Iteration 0: Elitist: 102.09947734325718
[2024-11-27 23:44:57,251][root][INFO] - Iteration 0 finished...
[2024-11-27 23:44:57,251][root][INFO] - Best obj: 102.09947734325718,Best obj func index: 5, Best Code Path: problem_iter0_code0.py
[2024-11-27 23:44:57,251][root][INFO] - Function Evals: 1
[2024-11-27 23:44:57,253][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are an expert-level algorithm engineer. Your task is to design efficient algorithms that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
There is a Markdown document that contains Python code along with relevant explanations. A target function `crossover` has been selected from this document.
Write a new `crossover` for problem:
Assisting in solving the Traveling Salesman Problem (TSP) with some prior heuristics. TSP requires finding the shortest path that visits all given nodes and returns to the starting node.

Function description:
The `crossover` function is designed to perform an ordered crossover operation between two parent routes represented as NumPy arrays, aimed at generating a new child route for use in genetic algorithms, particularly in solving the Traveling Salesman Problem (TSP). The function takes two inputs, `parent1` and `parent2`, which are both arrays of integers representing the order of points in the routes. It randomly selects a segment from `parent1` and retains it in the child route, ensuring that this segment's order is preserved. Subsequently, it fills the remaining positions in the child route with points from `parent2`, avoiding any duplicates. The output of the function is a NumPy array representing the newly created child route that inherits features from both parents, thus facilitating the exploration of potential solutions in the evolutionary algorithm context.

markdown document:
```python
import numpy as np
from scipy import spatial
from typing import Callable, Tuple

def initialize_population(num_points: int, pop_size: int) -> np.ndarray:
    """
    Initialize a population of random routes.
    
    Parameters:
    - num_points: int, number of points in the TSP.
    - pop_size: int, size of the population.
    
    Returns:
    - np.ndarray, population of routes.
    """
    population = [np.random.permutation(num_points) for _ in range(pop_size)]
    return np.array(population)

def calculate_fitness(population: np.ndarray, distance_matrix: np.ndarray, cal_total_distance: Callable) -> np.ndarray:
    """
    Calculate the fitness (total distance) for each route in the population.
    
    Parameters:
    - population: np.ndarray, population of routes.
    - distance_matrix: np.ndarray, distance matrix.
    - cal_total_distance: Callable, function to calculate total distance.
    
    Returns:
    - np.ndarray, fitness values for each route.
    """
    fitness = np.array([cal_total_distance(route, distance_matrix) for route in population])
    return fitness

def select_parents(population: np.ndarray, fitness: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    """
    Select parents based on fitness using roulette wheel selection.
    
    Parameters:
    - population: np.ndarray, population of routes.
    - fitness: np.ndarray, fitness values for each route.
    
    Returns:
    - Tuple[np.ndarray, np.ndarray], selected parents.
    """
    fitness = 1 / fitness  # Invert fitness to get higher values for better routes
    fitness_sum = np.sum(fitness)
    probabilities = fitness / fitness_sum
    indices = np.random.choice(len(population), size=2, p=probabilities, replace=False)
    return population[indices[0]], population[indices[1]]

def crossover(parent1: np.ndarray, parent2: np.ndarray) -> np.ndarray:
    """
    Perform ordered crossover to create a child route.
    
    Parameters:
    - parent1: np.ndarray, first parent route.
    - parent2: np.ndarray, second parent route.
    
    Returns:
    - np.ndarray, child route.
    """
    size = len(parent1)
    start, end = sorted(np.random.choice(size, 2, replace=False))
    child = np.zeros(size, dtype=int)
    child[start:end] = parent1[start:end]
    for i in range(size):
        if parent2[i] not in child:
            for j in range(size):
                if child[j] == 0:
                    child[j] = parent2[i]
                    break
    return child

def mutate(route: np.ndarray, mutation_rate: float) -> np.ndarray:
    """
    Mutate a route by swapping two points with a given mutation rate.
    
    Parameters:
    - route: np.ndarray, route to mutate.
    - mutation_rate: float, probability of mutation.
    
    Returns:
    - np.ndarray, mutated route.
    """
    if np.random.rand() < mutation_rate:
        idx1, idx2 = np.random.choice(len(route), 2, replace=False)
        route[idx1], route[idx2] = route[idx2], route[idx1]
    return route

def search_routine(cal_total_distance: Callable, distance_matrix: np.ndarray, pop_size: int = 100, num_generations: int = 1000, mutation_rate: float = 0.01) -> np.ndarray:
    """
    Perform the POMO algorithm to find the optimal route.
    
    Parameters:
    - cal_total_distance: Callable, function to calculate total distance.
    - distance_matrix: np.ndarray, distance matrix.
    - pop_size: int, size of the population.
    - num_generations: int, number of generations to run the algorithm.
    - mutation_rate: float, probability of mutation.
    
    Returns:
    - np.ndarray, best route found.
    """
    num_points = distance_matrix.shape[0]
    population = initialize_population(num_points, pop_size)
    
    for generation in range(num_generations):
        fitness = calculate_fitness(population, distance_matrix, cal_total_distance)
        new_population = []
        
        for _ in range(pop_size // 2):
            parent1, parent2 = select_parents(population, fitness)
            child1 = crossover(parent1, parent2)
            child2 = crossover(parent2, parent1)
            child1 = mutate(child1, mutation_rate)
            child2 = mutate(child2, mutation_rate)
            new_population.append(child1)
            new_population.append(child2)
        
        population = np.array(new_population)
    
    best_ind = population[np.argmin(calculate_fitness(population, distance_matrix, cal_total_distance))]
    return best_ind

if __name__ == "__main__":
    num_points = 50
    points_coordinate = np.random.rand(num_points, 2)  # generate coordinate of points
    distance_matrix = spatial.distance.cdist(points_coordinate, points_coordinate, metric='euclidean')
    
    best_route = search_routine(cal_total_distance, distance_matrix)
    print("Best Route:", best_route)
    print("Total Distance:", cal_total_distance(best_route, distance_matrix))
``````python
import numpy as np
from scipy import spatial
from typing import Callable, Tuple

def initialize_population(num_points: int, pop_size: int) -> np.ndarray:
    """
    Initialize a population of random routes.
    
    Parameters:
    - num_points: int, number of points in the TSP.
    - pop_size: int, size of the population.
    
    Returns:
    - np.ndarray, population of routes.
    """
    population = [np.random.permutation(num_points) for _ in range(pop_size)]
    return np.array(population)

def calculate_fitness(population: np.ndarray, distance_matrix: np.ndarray, cal_total_distance: Callable) -> np.ndarray:
    """
    Calculate the fitness (total distance) for each route in the population.
    
    Parameters:
    - population: np.ndarray, population of routes.
    - distance_matrix: np.ndarray, distance matrix.
    - cal_total_distance: Callable, function to calculate total distance.
    
    Returns:
    - np.ndarray, fitness values for each route.
    """
    fitness = np.array([cal_total_distance(route, distance_matrix) for route in population])
    return fitness

def select_parents(population: np.ndarray, fitness: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    """
    Select parents based on fitness using roulette wheel selection.
    
    Parameters:
    - population: np.ndarray, population of routes.
    - fitness: np.ndarray, fitness values for each route.
    
    Returns:
    - Tuple[np.ndarray, np.ndarray], selected parents.
    """
    fitness = 1 / fitness  # Invert fitness to get higher values for better routes
    fitness_sum = np.sum(fitness)
    probabilities = fitness / fitness_sum
    indices = np.random.choice(len(population), size=2, p=probabilities, replace=False)
    return population[indices[0]], population[indices[1]]

def crossover(parent1: np.ndarray, parent2: np.ndarray) -> np.ndarray:
    """
    Perform ordered crossover to create a child route.
    
    Parameters:
    - parent1: np.ndarray, first parent route.
    - parent2: np.ndarray, second parent route.
    
    Returns:
    - np.ndarray, child route.
    """
    size = len(parent1)
    start, end = sorted(np.random.choice(size, 2, replace=False))
    child = np.zeros(size, dtype=int)
    child[start:end] = parent1[start:end]
    for i in range(size):
        if parent2[i] not in child:
            for j in range(size):
                if child[j] == 0:
                    child[j] = parent2[i]
                    break
    return child

def mutate(route: np.ndarray, mutation_rate: float) -> np.ndarray:
    """
    Mutate a route by swapping two points with a given mutation rate.
    
    Parameters:
    - route: np.ndarray, route to mutate.
    - mutation_rate: float, probability of mutation.
    
    Returns:
    - np.ndarray, mutated route.
    """
    if np.random.rand() < mutation_rate:
        idx1, idx2 = np.random.choice(len(route), 2, replace=False)
        route[idx1], route[idx2] = route[idx2], route[idx1]
    return route

def search_routine(cal_total_distance: Callable, distance_matrix: np.ndarray, pop_size: int = 100, num_generations: int = 1000, mutation_rate: float = 0.01) -> np.ndarray:
    """
    Perform the POMO algorithm to find the optimal route.
    
    Parameters:
    - cal_total_distance: Callable, function to calculate total distance.
    - distance_matrix: np.ndarray, distance matrix.
    - pop_size: int, size of the population.
    - num_generations: int, number of generations to run the algorithm.
    - mutation_rate: float, probability of mutation.
    
    Returns:
    - np.ndarray, best route found.
    """
    num_points = distance_matrix.shape[0]
    population = initialize_population(num_points, pop_size)
    
    for generation in range(num_generations):
        fitness = calculate_fitness(population, distance_matrix, cal_total_distance)
        new_population = []
        
        for _ in range(pop_size // 2):
            parent1, parent2 = select_parents(population, fitness)
            child1 = crossover(parent1, parent2)
            child2 = crossover(parent2, parent1)
            child1 = mutate(child1, mutation_rate)
            child2 = mutate(child2, mutation_rate)
            new_population.append(child1)
            new_population.append(child2)
        
        population = np.array(new_population)
    
    best_ind = population[np.argmin(calculate_fitness(population, distance_matrix, cal_total_distance))]
    return best_ind

if __name__ == "__main__":
    num_points = 50
    points_coordinate = np.random.rand(num_points, 2)  # generate coordinate of points
    distance_matrix = spatial.distance.cdist(points_coordinate, points_coordinate, metric='euclidean')
    
    best_route = search_routine(cal_total_distance, distance_matrix)
    print("Best Route:", best_route)
    print("Total Distance:", cal_total_distance(best_route, distance_matrix))
```

```python
def crossover(parent1: np.ndarray, parent2: np.ndarray) -> np.ndarray:
    """
    Perform ordered crossover to create a child route.
    
    Parameters:
    - parent1: np.ndarray, first parent route.
    - parent2: np.ndarray, second parent route.
    
    Returns:
    - np.ndarray, child route.
    """
    size = len(parent1)
    start, end = sorted(np.random.choice(size, 2, replace=False))
    child = np.zeros(size, dtype=int)
    child[start:end] = parent1[start:end]
    for i in range(size):
        if parent2[i] not in child:
            for j in range(size):
                if child[j] == 0:
                    child[j] = parent2[i]
                    break
    return child

```

Refer to the format of a trivial design above. Be very creative and give `crossover_v2`. Output code only and enclose your code with Python code block: ```python ... ```.


