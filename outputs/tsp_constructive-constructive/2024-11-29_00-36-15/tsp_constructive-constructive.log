[2024-11-29 00:36:15,185][root][INFO] - Workspace: E:\all_works\iclr2025\AEL-P-SNE(1)\AEL-P-SNE\outputs\tsp_constructive-constructive\2024-11-29_00-36-15
[2024-11-29 00:36:15,185][root][INFO] - Project Root: E:\all_works\iclr2025\AEL-P-SNE(1)\AEL-P-SNE
[2024-11-29 00:36:15,187][root][INFO] - Using LLM: deepseek-coder
[2024-11-29 00:36:15,187][root][INFO] - Using Algorithm: reevo2d
[2024-11-29 00:36:16,654][root][INFO] - Problem: tsp_constructive
[2024-11-29 00:36:16,655][root][INFO] - Problem description: Solving Traveling Salesman Problem (TSP) with constructive heuristics. TSP requires finding the shortest path that visits all given nodes and returns to the starting node.
[2024-11-29 00:36:16,687][root][INFO] - Functions name: [initialize_pheromones,select_next_city,construct_solution,update_pheromones,search_routine]
[2024-11-29 00:36:16,691][root][INFO] - Evaluating seed function...
[2024-11-29 00:36:16,692][root][INFO] - Seed function code: 
from dataclasses import dataclass
import random
from typing import Callable
import numpy as np
def initialize_pheromones(distance_matrix: np.ndarray, initial_pheromone: float = 1.0) -> np.ndarray:
    """Initialize the pheromone matrix with a constant value."""
    return np.full_like(distance_matrix, initial_pheromone, dtype=float)
def select_next_city(current_city: int, unvisited_cities: np.ndarray, pheromone_matrix: np.ndarray, distance_matrix: np.ndarray, alpha: float, beta: float) -> int:
    """Select the next city based on the pheromone and distance information."""
    pheromone = pheromone_matrix[current_city, unvisited_cities]
    distance = distance_matrix[current_city, unvisited_cities]
    attractiveness = (pheromone ** alpha) * ((1.0 / distance) ** beta)
    probabilities = attractiveness / np.sum(attractiveness)
    next_city = np.random.choice(unvisited_cities, p=probabilities)
    return next_city
def construct_solution(pheromone_matrix: np.ndarray, distance_matrix: np.ndarray, alpha: float, beta: float) -> np.ndarray:
    """Construct a solution (tour) for a single ant."""
    num_cities = distance_matrix.shape[0]
    start_city = np.random.randint(num_cities)
    tour = [start_city]
    unvisited_cities = np.delete(np.arange(num_cities), start_city)
    
    for _ in range(num_cities - 1):
        current_city = tour[-1]
        next_city = select_next_city(current_city, unvisited_cities, pheromone_matrix, distance_matrix, alpha, beta)
        tour.append(next_city)
        unvisited_cities = np.delete(unvisited_cities, np.where(unvisited_cities == next_city))
    
    return np.array(tour)
def update_pheromones(pheromone_matrix: np.ndarray, tours: np.ndarray, distances: np.ndarray, evaporation_rate: float, Q: float) -> np.ndarray:
    """Update the pheromone matrix based on the tours and their distances."""
    pheromone_matrix *= (1.0 - evaporation_rate)
    for tour, distance in zip(tours, distances):
        for i in range(len(tour) - 1):
            current_city = tour[i]
            next_city = tour[i + 1]
            pheromone_matrix[current_city, next_city] += Q / distance
            pheromone_matrix[next_city, current_city] += Q / distance
    return pheromone_matrix
def search_routine(cal_total_distance: Callable, distance_matrix: np.ndarray, pop_size: int = 100, num_generations: int = 1000, mutation_rate: float = 0.01, alpha: float = 1.0, beta: float = 5.0, evaporation_rate: float = 0.5, Q: float = 100.0) -> np.ndarray:
    """Search for the optimal TSP routine using Ant Colony Optimization."""
    num_cities = distance_matrix.shape[0]
    pheromone_matrix = initialize_pheromones(distance_matrix)
    best_tour = None
    best_distance = np.inf
    
    for generation in range(num_generations):
        tours = np.array([construct_solution(pheromone_matrix, distance_matrix, alpha, beta) for _ in range(pop_size)])
        distances = np.array([cal_total_distance(tour, distance_matrix) for tour in tours])
        
        if np.min(distances) < best_distance:
            best_distance = np.min(distances)
            best_tour = tours[np.argmin(distances)]
        
        pheromone_matrix = update_pheromones(pheromone_matrix, tours, distances, evaporation_rate, Q)
    
    return best_tour
[2024-11-29 00:36:16,696][root][INFO] - Iteration 0: Running Code 0
[2024-11-29 00:36:17,320][root][INFO] - Iteration 0: Code Run 0 successful!
[2024-11-29 00:36:44,566][root][INFO] - Iteration 0, response_id 0: Objective value: 5.969775827565783
[2024-11-29 00:36:44,566][root][INFO] - Iteration 0: Elitist: 5.969775827565783
[2024-11-29 00:36:44,567][root][INFO] - Iteration 0 finished...
[2024-11-29 00:36:44,567][root][INFO] - Best obj: 5.969775827565783,Best obj func index: 4, Best Code Path: problem_iter0_code0.py
[2024-11-29 00:36:44,567][root][INFO] - Function Evals: 1
[2024-11-29 00:36:44,568][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are an expert-level algorithm engineer. Your task is to design efficient algorithms that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
There is a Markdown document that contains Python code along with relevant explanations. A target function `initialize_pheromones` has been selected from this document.
Write a new `initialize_pheromones` for problem:
Solving Traveling Salesman Problem (TSP) with constructive heuristics. TSP requires finding the shortest path that visits all given nodes and returns to the starting node.

Function description:
The `initialize_pheromones` function is designed to create and return a pheromone matrix for use in an Ant Colony Optimization (ACO) algorithm aimed at solving the Traveling Salesman Problem (TSP). It takes two inputs: `distance_matrix`, a 2D NumPy array representing the distances between each pair of cities (points), and an optional parameter `initial_pheromone`, which defaults to 1.0 and specifies the initial pheromone level to be uniformly assigned across the matrix. The output is a 2D NumPy array of the same shape as `distance_matrix`, filled with the provided `initial_pheromone` value. The purpose of this function is to set up the pheromone levels, which will be updated throughout the ACO algorithm as ants traverse the cities, reflecting the quality of the paths discovered.

markdown document:
To solve the Traveling Salesman Problem (TSP) using an Ant Colony Optimization (ACO) algorithm, we can implement the `search_routine` function. The ACO algorithm simulates the behavior of ants searching for the shortest path between their colony and a food source. Here, we'll adapt this behavior to find the shortest path through a set of points.

Below is the implementation of the `search_routine` function along with utility functions to support the ACO algorithm.

```python
import numpy as np
from scipy import spatial
from typing import Callable, Tuple

def initialize_pheromones(distance_matrix: np.ndarray, initial_pheromone: float = 1.0) -> np.ndarray:
    """Initialize the pheromone matrix with a constant value."""
    return np.full_like(distance_matrix, initial_pheromone, dtype=float)

def select_next_city(current_city: int, unvisited_cities: np.ndarray, pheromone_matrix: np.ndarray, distance_matrix: np.ndarray, alpha: float, beta: float) -> int:
    """Select the next city based on the pheromone and distance information."""
    pheromone = pheromone_matrix[current_city, unvisited_cities]
    distance = distance_matrix[current_city, unvisited_cities]
    attractiveness = (pheromone ** alpha) * ((1.0 / distance) ** beta)
    probabilities = attractiveness / np.sum(attractiveness)
    next_city = np.random.choice(unvisited_cities, p=probabilities)
    return next_city

def construct_solution(pheromone_matrix: np.ndarray, distance_matrix: np.ndarray, alpha: float, beta: float) -> np.ndarray:
    """Construct a solution (tour) for a single ant."""
    num_cities = distance_matrix.shape[0]
    start_city = np.random.randint(num_cities)
    tour = [start_city]
    unvisited_cities = np.delete(np.arange(num_cities), start_city)
    
    for _ in range(num_cities - 1):
        current_city = tour[-1]
        next_city = select_next_city(current_city, unvisited_cities, pheromone_matrix, distance_matrix, alpha, beta)
        tour.append(next_city)
        unvisited_cities = np.delete(unvisited_cities, np.where(unvisited_cities == next_city))
    
    return np.array(tour)

def update_pheromones(pheromone_matrix: np.ndarray, tours: np.ndarray, distances: np.ndarray, evaporation_rate: float, Q: float) -> np.ndarray:
    """Update the pheromone matrix based on the tours and their distances."""
    pheromone_matrix *= (1.0 - evaporation_rate)
    for tour, distance in zip(tours, distances):
        for i in range(len(tour) - 1):
            current_city = tour[i]
            next_city = tour[i + 1]
            pheromone_matrix[current_city, next_city] += Q / distance
            pheromone_matrix[next_city, current_city] += Q / distance
    return pheromone_matrix

def search_routine(cal_total_distance: Callable, distance_matrix: np.ndarray, pop_size: int = 100, num_generations: int = 1000, mutation_rate: float = 0.01, alpha: float = 1.0, beta: float = 5.0, evaporation_rate: float = 0.5, Q: float = 100.0) -> np.ndarray:
    """Search for the optimal TSP routine using Ant Colony Optimization."""
    num_cities = distance_matrix.shape[0]
    pheromone_matrix = initialize_pheromones(distance_matrix)
    best_tour = None
    best_distance = np.inf
    
    for generation in range(num_generations):
        tours = np.array([construct_solution(pheromone_matrix, distance_matrix, alpha, beta) for _ in range(pop_size)])
        distances = np.array([cal_total_distance(tour, distance_matrix) for tour in tours])
        
        if np.min(distances) < best_distance:
            best_distance = np.min(distances)
            best_tour = tours[np.argmin(distances)]
        
        pheromone_matrix = update_pheromones(pheromone_matrix, tours, distances, evaporation_rate, Q)
    
    return best_tour

if __name__ == "__main__":
    num_points = 50
    points_coordinate = np.random.rand(num_points, 2)  # generate coordinate of points
    distance_matrix = spatial.distance.cdist(points_coordinate, points_coordinate, metric='euclidean')
    
    def cal_total_distance(routine, distance_matrix):
        '''The objective function. input routine, return total distance.'''
        expected = np.arange(len(routine))
        sorted_arr = np.sort(routine)
        if not np.array_equal(sorted_arr, expected):
            raise ValueError("Routine does not adhere to TSP constraints")
        next_points = np.roll(routine, -1)
        distances = distance_matrix[routine, next_points]
        return np.sum(distances)
    
    best_tour = search_routine(cal_total_distance, distance_matrix)
    print("Best tour found:", best_tour)
    print("Total distance of the best tour:", cal_total_distance(best_tour, distance_matrix))
```

### Explanation:
1. **Initialization**:
   - `initialize_pheromones`: Initializes the pheromone matrix with a constant value.
   - `select_next_city`: Selects the next city for an ant based on pheromone and distance information.
   - `construct_solution`: Constructs a complete tour for a single ant.
   - `update_pheromones`: Updates the pheromone matrix based on the tours and their distances.

2. **Main Function**:
   - `search_routine`: Implements the ACO algorithm to find the optimal TSP routine. It iteratively constructs tours for multiple ants, updates the pheromone matrix, and keeps track of the best tour found.

3. **Test Code**:
   - The test code generates random points, computes the distance matrix, and uses the `search_routine` function to find the best tour. It then prints the best tour and its total distance.

This implementation ensures that the algorithm is modular, with each function performing a specific task, and maintains high precision in numerical computations.To solve the Traveling Salesman Problem (TSP) using an Ant Colony Optimization (ACO) algorithm, we can implement the `search_routine` function. The ACO algorithm simulates the behavior of ants searching for the shortest path between their colony and a food source. Here, we'll adapt this behavior to find the shortest path through a set of points.

Below is the implementation of the `search_routine` function along with utility functions to support the ACO algorithm.

```python
import numpy as np
from scipy import spatial
from typing import Callable, Tuple

def initialize_pheromones(distance_matrix: np.ndarray, initial_pheromone: float = 1.0) -> np.ndarray:
    """Initialize the pheromone matrix with a constant value."""
    return np.full_like(distance_matrix, initial_pheromone, dtype=float)

def select_next_city(current_city: int, unvisited_cities: np.ndarray, pheromone_matrix: np.ndarray, distance_matrix: np.ndarray, alpha: float, beta: float) -> int:
    """Select the next city based on the pheromone and distance information."""
    pheromone = pheromone_matrix[current_city, unvisited_cities]
    distance = distance_matrix[current_city, unvisited_cities]
    attractiveness = (pheromone ** alpha) * ((1.0 / distance) ** beta)
    probabilities = attractiveness / np.sum(attractiveness)
    next_city = np.random.choice(unvisited_cities, p=probabilities)
    return next_city

def construct_solution(pheromone_matrix: np.ndarray, distance_matrix: np.ndarray, alpha: float, beta: float) -> np.ndarray:
    """Construct a solution (tour) for a single ant."""
    num_cities = distance_matrix.shape[0]
    start_city = np.random.randint(num_cities)
    tour = [start_city]
    unvisited_cities = np.delete(np.arange(num_cities), start_city)
    
    for _ in range(num_cities - 1):
        current_city = tour[-1]
        next_city = select_next_city(current_city, unvisited_cities, pheromone_matrix, distance_matrix, alpha, beta)
        tour.append(next_city)
        unvisited_cities = np.delete(unvisited_cities, np.where(unvisited_cities == next_city))
    
    return np.array(tour)

def update_pheromones(pheromone_matrix: np.ndarray, tours: np.ndarray, distances: np.ndarray, evaporation_rate: float, Q: float) -> np.ndarray:
    """Update the pheromone matrix based on the tours and their distances."""
    pheromone_matrix *= (1.0 - evaporation_rate)
    for tour, distance in zip(tours, distances):
        for i in range(len(tour) - 1):
            current_city = tour[i]
            next_city = tour[i + 1]
            pheromone_matrix[current_city, next_city] += Q / distance
            pheromone_matrix[next_city, current_city] += Q / distance
    return pheromone_matrix

def search_routine(cal_total_distance: Callable, distance_matrix: np.ndarray, pop_size: int = 100, num_generations: int = 1000, mutation_rate: float = 0.01, alpha: float = 1.0, beta: float = 5.0, evaporation_rate: float = 0.5, Q: float = 100.0) -> np.ndarray:
    """Search for the optimal TSP routine using Ant Colony Optimization."""
    num_cities = distance_matrix.shape[0]
    pheromone_matrix = initialize_pheromones(distance_matrix)
    best_tour = None
    best_distance = np.inf
    
    for generation in range(num_generations):
        tours = np.array([construct_solution(pheromone_matrix, distance_matrix, alpha, beta) for _ in range(pop_size)])
        distances = np.array([cal_total_distance(tour, distance_matrix) for tour in tours])
        
        if np.min(distances) < best_distance:
            best_distance = np.min(distances)
            best_tour = tours[np.argmin(distances)]
        
        pheromone_matrix = update_pheromones(pheromone_matrix, tours, distances, evaporation_rate, Q)
    
    return best_tour

if __name__ == "__main__":
    num_points = 50
    points_coordinate = np.random.rand(num_points, 2)  # generate coordinate of points
    distance_matrix = spatial.distance.cdist(points_coordinate, points_coordinate, metric='euclidean')
    
    def cal_total_distance(routine, distance_matrix):
        '''The objective function. input routine, return total distance.'''
        expected = np.arange(len(routine))
        sorted_arr = np.sort(routine)
        if not np.array_equal(sorted_arr, expected):
            raise ValueError("Routine does not adhere to TSP constraints")
        next_points = np.roll(routine, -1)
        distances = distance_matrix[routine, next_points]
        return np.sum(distances)
    
    best_tour = search_routine(cal_total_distance, distance_matrix)
    print("Best tour found:", best_tour)
    print("Total distance of the best tour:", cal_total_distance(best_tour, distance_matrix))
```

### Explanation:
1. **Initialization**:
   - `initialize_pheromones`: Initializes the pheromone matrix with a constant value.
   - `select_next_city`: Selects the next city for an ant based on pheromone and distance information.
   - `construct_solution`: Constructs a complete tour for a single ant.
   - `update_pheromones`: Updates the pheromone matrix based on the tours and their distances.

2. **Main Function**:
   - `search_routine`: Implements the ACO algorithm to find the optimal TSP routine. It iteratively constructs tours for multiple ants, updates the pheromone matrix, and keeps track of the best tour found.

3. **Test Code**:
   - The test code generates random points, computes the distance matrix, and uses the `search_routine` function to find the best tour. It then prints the best tour and its total distance.

This implementation ensures that the algorithm is modular, with each function performing a specific task, and maintains high precision in numerical computations.

```python
def initialize_pheromones(distance_matrix: np.ndarray, initial_pheromone: float = 1.0) -> np.ndarray:
    """Initialize the pheromone matrix with a constant value."""
    return np.full_like(distance_matrix, initial_pheromone, dtype=float)

```

Refer to the format of a trivial design above. Be very creative and give `initialize_pheromones_v2`. Output code only and enclose your code with Python code block: ```python ... ```.


[2024-11-29 00:36:44,907][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:36:44,908][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:36:45,055][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:36:45,175][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:36:45,175][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:36:45,388][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:36:45,429][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:36:45,439][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:36:45,599][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:36:45,644][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:37:06,025][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are an expert-level algorithm engineer. Your task is to design efficient algorithms that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
There is a Markdown document that contains Python code along with relevant explanations. A target function `select_next_city` has been selected from this document.
Write a new `select_next_city` for problem:
Solving Traveling Salesman Problem (TSP) with constructive heuristics. TSP requires finding the shortest path that visits all given nodes and returns to the starting node.

Function description:
The `select_next_city` function is designed to select the next city for an ant in the context of the Ant Colony Optimization (ACO) algorithm, specifically for solving the Traveling Salesman Problem (TSP). The function takes several inputs: the current city (as an integer), an array of unvisited cities (as a NumPy ndarray), a pheromone matrix (indicating the pheromone levels on city paths), a distance matrix (containing the distances between cities), and two parameters, alpha and beta, which dictate the influence of pheromone and distance, respectively. The function computes a probability distribution based on the attractiveness of unvisited cities, weighted by both pheromone levels and the inverse of the distances to those cities. It then randomly selects the next city according to this probability distribution. The output of the function is the index of the selected next city (an integer), which will guide the ant in its journey through the city network.

markdown document:
To solve the Traveling Salesman Problem (TSP) using an Ant Colony Optimization (ACO) algorithm, we can implement the `search_routine` function. The ACO algorithm simulates the behavior of ants searching for the shortest path between their colony and a food source. Here, we'll adapt this behavior to find the shortest path through a set of points.

Below is the implementation of the `search_routine` function along with utility functions to support the ACO algorithm.

```python
import numpy as np
from scipy import spatial
from typing import Callable, Tuple

def initialize_pheromones(distance_matrix: np.ndarray, initial_pheromone: float = 1.0) -> np.ndarray:
    """Initialize the pheromone matrix with a constant value."""
    return np.full_like(distance_matrix, initial_pheromone, dtype=float)

def select_next_city(current_city: int, unvisited_cities: np.ndarray, pheromone_matrix: np.ndarray, distance_matrix: np.ndarray, alpha: float, beta: float) -> int:
    """Select the next city based on the pheromone and distance information."""
    pheromone = pheromone_matrix[current_city, unvisited_cities]
    distance = distance_matrix[current_city, unvisited_cities]
    attractiveness = (pheromone ** alpha) * ((1.0 / distance) ** beta)
    probabilities = attractiveness / np.sum(attractiveness)
    next_city = np.random.choice(unvisited_cities, p=probabilities)
    return next_city

def construct_solution(pheromone_matrix: np.ndarray, distance_matrix: np.ndarray, alpha: float, beta: float) -> np.ndarray:
    """Construct a solution (tour) for a single ant."""
    num_cities = distance_matrix.shape[0]
    start_city = np.random.randint(num_cities)
    tour = [start_city]
    unvisited_cities = np.delete(np.arange(num_cities), start_city)
    
    for _ in range(num_cities - 1):
        current_city = tour[-1]
        next_city = select_next_city(current_city, unvisited_cities, pheromone_matrix, distance_matrix, alpha, beta)
        tour.append(next_city)
        unvisited_cities = np.delete(unvisited_cities, np.where(unvisited_cities == next_city))
    
    return np.array(tour)

def update_pheromones(pheromone_matrix: np.ndarray, tours: np.ndarray, distances: np.ndarray, evaporation_rate: float, Q: float) -> np.ndarray:
    """Update the pheromone matrix based on the tours and their distances."""
    pheromone_matrix *= (1.0 - evaporation_rate)
    for tour, distance in zip(tours, distances):
        for i in range(len(tour) - 1):
            current_city = tour[i]
            next_city = tour[i + 1]
            pheromone_matrix[current_city, next_city] += Q / distance
            pheromone_matrix[next_city, current_city] += Q / distance
    return pheromone_matrix

def search_routine(cal_total_distance: Callable, distance_matrix: np.ndarray, pop_size: int = 100, num_generations: int = 1000, mutation_rate: float = 0.01, alpha: float = 1.0, beta: float = 5.0, evaporation_rate: float = 0.5, Q: float = 100.0) -> np.ndarray:
    """Search for the optimal TSP routine using Ant Colony Optimization."""
    num_cities = distance_matrix.shape[0]
    pheromone_matrix = initialize_pheromones(distance_matrix)
    best_tour = None
    best_distance = np.inf
    
    for generation in range(num_generations):
        tours = np.array([construct_solution(pheromone_matrix, distance_matrix, alpha, beta) for _ in range(pop_size)])
        distances = np.array([cal_total_distance(tour, distance_matrix) for tour in tours])
        
        if np.min(distances) < best_distance:
            best_distance = np.min(distances)
            best_tour = tours[np.argmin(distances)]
        
        pheromone_matrix = update_pheromones(pheromone_matrix, tours, distances, evaporation_rate, Q)
    
    return best_tour

if __name__ == "__main__":
    num_points = 50
    points_coordinate = np.random.rand(num_points, 2)  # generate coordinate of points
    distance_matrix = spatial.distance.cdist(points_coordinate, points_coordinate, metric='euclidean')
    
    def cal_total_distance(routine, distance_matrix):
        '''The objective function. input routine, return total distance.'''
        expected = np.arange(len(routine))
        sorted_arr = np.sort(routine)
        if not np.array_equal(sorted_arr, expected):
            raise ValueError("Routine does not adhere to TSP constraints")
        next_points = np.roll(routine, -1)
        distances = distance_matrix[routine, next_points]
        return np.sum(distances)
    
    best_tour = search_routine(cal_total_distance, distance_matrix)
    print("Best tour found:", best_tour)
    print("Total distance of the best tour:", cal_total_distance(best_tour, distance_matrix))
```

### Explanation:
1. **Initialization**:
   - `initialize_pheromones`: Initializes the pheromone matrix with a constant value.
   - `select_next_city`: Selects the next city for an ant based on pheromone and distance information.
   - `construct_solution`: Constructs a complete tour for a single ant.
   - `update_pheromones`: Updates the pheromone matrix based on the tours and their distances.

2. **Main Function**:
   - `search_routine`: Implements the ACO algorithm to find the optimal TSP routine. It iteratively constructs tours for multiple ants, updates the pheromone matrix, and keeps track of the best tour found.

3. **Test Code**:
   - The test code generates random points, computes the distance matrix, and uses the `search_routine` function to find the best tour. It then prints the best tour and its total distance.

This implementation ensures that the algorithm is modular, with each function performing a specific task, and maintains high precision in numerical computations.To solve the Traveling Salesman Problem (TSP) using an Ant Colony Optimization (ACO) algorithm, we can implement the `search_routine` function. The ACO algorithm simulates the behavior of ants searching for the shortest path between their colony and a food source. Here, we'll adapt this behavior to find the shortest path through a set of points.

Below is the implementation of the `search_routine` function along with utility functions to support the ACO algorithm.

```python
import numpy as np
from scipy import spatial
from typing import Callable, Tuple

def initialize_pheromones(distance_matrix: np.ndarray, initial_pheromone: float = 1.0) -> np.ndarray:
    """Initialize the pheromone matrix with a constant value."""
    return np.full_like(distance_matrix, initial_pheromone, dtype=float)

def select_next_city(current_city: int, unvisited_cities: np.ndarray, pheromone_matrix: np.ndarray, distance_matrix: np.ndarray, alpha: float, beta: float) -> int:
    """Select the next city based on the pheromone and distance information."""
    pheromone = pheromone_matrix[current_city, unvisited_cities]
    distance = distance_matrix[current_city, unvisited_cities]
    attractiveness = (pheromone ** alpha) * ((1.0 / distance) ** beta)
    probabilities = attractiveness / np.sum(attractiveness)
    next_city = np.random.choice(unvisited_cities, p=probabilities)
    return next_city

def construct_solution(pheromone_matrix: np.ndarray, distance_matrix: np.ndarray, alpha: float, beta: float) -> np.ndarray:
    """Construct a solution (tour) for a single ant."""
    num_cities = distance_matrix.shape[0]
    start_city = np.random.randint(num_cities)
    tour = [start_city]
    unvisited_cities = np.delete(np.arange(num_cities), start_city)
    
    for _ in range(num_cities - 1):
        current_city = tour[-1]
        next_city = select_next_city(current_city, unvisited_cities, pheromone_matrix, distance_matrix, alpha, beta)
        tour.append(next_city)
        unvisited_cities = np.delete(unvisited_cities, np.where(unvisited_cities == next_city))
    
    return np.array(tour)

def update_pheromones(pheromone_matrix: np.ndarray, tours: np.ndarray, distances: np.ndarray, evaporation_rate: float, Q: float) -> np.ndarray:
    """Update the pheromone matrix based on the tours and their distances."""
    pheromone_matrix *= (1.0 - evaporation_rate)
    for tour, distance in zip(tours, distances):
        for i in range(len(tour) - 1):
            current_city = tour[i]
            next_city = tour[i + 1]
            pheromone_matrix[current_city, next_city] += Q / distance
            pheromone_matrix[next_city, current_city] += Q / distance
    return pheromone_matrix

def search_routine(cal_total_distance: Callable, distance_matrix: np.ndarray, pop_size: int = 100, num_generations: int = 1000, mutation_rate: float = 0.01, alpha: float = 1.0, beta: float = 5.0, evaporation_rate: float = 0.5, Q: float = 100.0) -> np.ndarray:
    """Search for the optimal TSP routine using Ant Colony Optimization."""
    num_cities = distance_matrix.shape[0]
    pheromone_matrix = initialize_pheromones(distance_matrix)
    best_tour = None
    best_distance = np.inf
    
    for generation in range(num_generations):
        tours = np.array([construct_solution(pheromone_matrix, distance_matrix, alpha, beta) for _ in range(pop_size)])
        distances = np.array([cal_total_distance(tour, distance_matrix) for tour in tours])
        
        if np.min(distances) < best_distance:
            best_distance = np.min(distances)
            best_tour = tours[np.argmin(distances)]
        
        pheromone_matrix = update_pheromones(pheromone_matrix, tours, distances, evaporation_rate, Q)
    
    return best_tour

if __name__ == "__main__":
    num_points = 50
    points_coordinate = np.random.rand(num_points, 2)  # generate coordinate of points
    distance_matrix = spatial.distance.cdist(points_coordinate, points_coordinate, metric='euclidean')
    
    def cal_total_distance(routine, distance_matrix):
        '''The objective function. input routine, return total distance.'''
        expected = np.arange(len(routine))
        sorted_arr = np.sort(routine)
        if not np.array_equal(sorted_arr, expected):
            raise ValueError("Routine does not adhere to TSP constraints")
        next_points = np.roll(routine, -1)
        distances = distance_matrix[routine, next_points]
        return np.sum(distances)
    
    best_tour = search_routine(cal_total_distance, distance_matrix)
    print("Best tour found:", best_tour)
    print("Total distance of the best tour:", cal_total_distance(best_tour, distance_matrix))
```

### Explanation:
1. **Initialization**:
   - `initialize_pheromones`: Initializes the pheromone matrix with a constant value.
   - `select_next_city`: Selects the next city for an ant based on pheromone and distance information.
   - `construct_solution`: Constructs a complete tour for a single ant.
   - `update_pheromones`: Updates the pheromone matrix based on the tours and their distances.

2. **Main Function**:
   - `search_routine`: Implements the ACO algorithm to find the optimal TSP routine. It iteratively constructs tours for multiple ants, updates the pheromone matrix, and keeps track of the best tour found.

3. **Test Code**:
   - The test code generates random points, computes the distance matrix, and uses the `search_routine` function to find the best tour. It then prints the best tour and its total distance.

This implementation ensures that the algorithm is modular, with each function performing a specific task, and maintains high precision in numerical computations.

```python
def select_next_city(current_city: int, unvisited_cities: np.ndarray, pheromone_matrix: np.ndarray, distance_matrix: np.ndarray, alpha: float, beta: float) -> int:
    """Select the next city based on the pheromone and distance information."""
    pheromone = pheromone_matrix[current_city, unvisited_cities]
    distance = distance_matrix[current_city, unvisited_cities]
    attractiveness = (pheromone ** alpha) * ((1.0 / distance) ** beta)
    probabilities = attractiveness / np.sum(attractiveness)
    next_city = np.random.choice(unvisited_cities, p=probabilities)
    return next_city

```

Refer to the format of a trivial design above. Be very creative and give `select_next_city_v2`. Output code only and enclose your code with Python code block: ```python ... ```.


[2024-11-29 00:37:06,304][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:37:06,356][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:37:06,499][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:37:06,603][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:37:06,777][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:37:06,888][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:37:07,040][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:37:07,127][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:37:07,193][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
[2024-11-29 00:37:07,265][httpx][INFO] - HTTP Request: POST https://api.deepseek.com/chat/completions "HTTP/1.1 200 OK"
